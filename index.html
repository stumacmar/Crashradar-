<script>
'use strict';

const MACRO_BLOCK_WEIGHT = 0.70;
const VALUATION_BLOCK_WEIGHT = 0.30;
const WARN_MAX = 30;

let cacheAgeDays = null;

const INDICATORS = {
  LEI: {
    tier:1,
    label:'Conference Board LEI 6m %Δ',
    weight:0.15,
    threshold:-3.5,
    direction:'below',
    span:3.0,
    fromFred:false,
    fredId:null,
    current:null,
    format:v => v.toFixed(1) + '%',
    desc:'Manual. 6m % change in LEI. ≤ -3.5% has preceded most post-1960 recessions.'
  },
  YIELD_CURVE: {
    tier:1,
    label:'Yield Curve (10y–3m)',
    weight:0.12,
    threshold:0.0,
    direction:'below',
    span:1.0,
    fromFred:true,
    fredId:'T10Y3M',
    current:null,
    format:v => v.toFixed(2) + ' pp',
    desc:'10y–3m spread. Inversions (≤0) are classic recession leads.'
  },
  CREDIT_SPREAD: {
    tier:1,
    label:'HY Credit Spread',
    weight:0.10,
    threshold:5.0,
    direction:'above',
    span:3.0,
    fromFred:true,
    fredId:'BAMLH0A0HYM2',
    current:null,
    format:v => v.toFixed(2) + ' pp',
    desc:'US HY OAS. >5% = stress, >8% = crisis-like conditions.'
  },
  FIN_STRESS: {
    tier:1,
    label:'Financial Stress (NFCI)',
    weight:0.08,
    threshold:0.0,
    direction:'above',
    span:0.5,
    fromFred:true,
    fredId:'NFCI',
    current:null,
    format:v => v.toFixed(2),
    desc:'Chicago Fed NFCI. >0 indicates tighter-than-average conditions.'
  },
  CONSUMER_SENTIMENT: {
    tier:1,
    label:'UMich Sentiment',
    weight:0.08,
    threshold:60.0,
    direction:'below',
    span:25.0,
    fromFred:true,
    fredId:'UMCSENT',
    current:null,
    format:v => v.toFixed(1),
    desc:'Deep pessimism. Sustained <60 readings cluster around recessions.'
  },
  M2_GROWTH: {
    tier:1,
    label:'M2 Growth YoY',
    weight:0.08,
    threshold:0.0,
    direction:'below',
    span:6.0,
    fromFred:true,
    fredId:'M2SL',
    current:null,
    format:v => v.toFixed(1) + '%',
    desc:'YoY growth from M2SL. ≤0% is historically rare and restrictive.'
  },
  INDUSTRIAL_PRODUCTION: {
    tier:2,
    label:'Industrial Production YoY',
    weight:0.07,
    threshold:0.0,
    direction:'below',
    span:5.0,
    fromFred:true,
    fredId:'INDPRO',
    current:null,
    format:v => v.toFixed(1) + '%',
    desc:'YoY change. Sustained contraction confirms downturn.'
  },
  BUILDING_PERMITS: {
    tier:2,
    label:'Building Permits 6m %Δ',
    weight:0.07,
    threshold:-10.0,
    direction:'below',
    span:10.0,
    fromFred:true,
    fredId:'PERMIT',
    current:null,
    format:v => v.toFixed(1) + '%',
    desc:'6m % change. Sharp drops lead housing & broader weakness.'
  },
  INITIAL_CLAIMS: {
    tier:2,
    label:'Initial Claims 4wk MA (k)',
    weight:0.08,
    threshold:325,
    direction:'above',
    span:150,
    fromFred:true,
    fredId:'ICSA',
    current:null,
    format:v => Math.round(v) + 'k',
    desc:'4-week avg in thousands. >325k consistent with labor market stress.'
  },
  SAHM_RULE: {
    tier:2,
    label:'Sahm Rule (pp)',
    weight:0.07,
    threshold:0.50,
    direction:'above',
    span:0.5,
    fromFred:true,
    fredId:'SAHMREALTIME',
    current:null,
    format:v => v.toFixed(2),
    desc:'≥0.50 triggers real-time recession signal.'
  }
};

const VALUATIONS = {
  BUFFETT: {
    label:'Buffett Indicator (MktCap/GDP)',
    weight:0.50,
    danger:200,
    current:null,
    format:v => v.toFixed(1) + '%',
    desc:'>150% stretched; >200% historically extreme.'
  },
  SHILLER_PE: {
    label:'Shiller CAPE',
    weight:0.50,
    danger:30,
    current:null,
    format:v => v.toFixed(1),
    desc:'>25 elevated; >30 associated with poor long-run returns.'
  }
};

let charts = { trend:null, radar:null };
let compositeScore = null;

/**
 * Load FRED cache (data/fred_cache.json).
 */
async function loadFromFredCache(){
  try{
    const res = await fetch('data/fred_cache.json', { cache:'no-store' });
    if(!res.ok){
      console.error('FRED cache HTTP error', res.status);
      document.getElementById('cache-badge').textContent = 'FRED cache: not found';
      return;
    }

    const cache = await res.json();
    const series = cache.series || {};
    const gen = cache.generated_at || 'loaded';
    document.getElementById('cache-badge').textContent = 'FRED cache: ' + gen;

    const genDate = new Date(gen);
    if(!isNaN(genDate)){
      const now = new Date();
      cacheAgeDays = (now - genDate) / (1000*60*60*24);
      if(cacheAgeDays < 0) cacheAgeDays = null;
    }

    function lastVal(id){
      const s = series[id];
      if(!s) return null;
      if(Array.isArray(s.observations) && s.observations.length){
        for(let i = s.observations.length - 1; i >= 0; i--){
          const v = Number(s.observations[i].value);
          if(Number.isFinite(v)) return v;
        }
        return null;
      }
      if(typeof s.value !== 'undefined'){
        const v = Number(s.value);
        return Number.isFinite(v) ? v : null;
      }
      return null;
    }

    function obsMonthsBack(id, months){
      const s = series[id];
      if(!s || !Array.isArray(s.observations) || !s.observations.length) return null;
      const last = s.observations[s.observations.length - 1];
      const lastDate = new Date(last.date);
      if(isNaN(lastDate)) return null;
      const target = new Date(lastDate);
      target.setMonth(target.getMonth() - months);
      let candidate = null;
      for(let i=0;i<s.observations.length;i++){
        const o = s.observations[i];
        const d = new Date(o.date);
        if(isNaN(d)) continue;
        if(d <= target) candidate = o; else break;
      }
      return candidate;
    }

    function rollingAvgLastN(id, n){
      const s = series[id];
      if(!s || !Array.isArray(s.observations) || s.observations.length < n) return null;
      const slice = s.observations.slice(-n);
      const vals = slice.map(o => Number(o.value)).filter(v => Number.isFinite(v));
      if(vals.length < n) return null;
      const sum = vals.reduce((a,b)=>a+b,0);
      return sum / n;
    }

    function pctChange(nv, ov){
      const n = Number(nv), o = Number(ov);
      if(!Number.isFinite(n) || !Number.isFinite(o) || o === 0) return null;
      return ((n - o) / o) * 100;
    }

    // Populate indicators from FRED
    Object.keys(INDICATORS).forEach(key => {
      const ind = INDICATORS[key];
      if(!ind.fromFred || !ind.fredId) return;

      if(ind.fredId === 'M2SL'){
        const lvlNow = lastVal('M2SL');
        const back = obsMonthsBack('M2SL', 12);
        if(lvlNow != null && back && back.value != null){
          const pc = pctChange(lvlNow, back.value);
          if(pc != null) ind.current = pc;
        }
      } else if(ind.fredId === 'INDPRO'){
        const lvlNow = lastVal('INDPRO');
        const back = obsMonthsBack('INDPRO', 12);
        if(lvlNow != null && back && back.value != null){
          const pc = pctChange(lvlNow, back.value);
          if(pc != null) ind.current = pc;
        }
      } else if(ind.fredId === 'PERMIT'){
        const now = lastVal('PERMIT');
        const back = obsMonthsBack('PERMIT', 6);
        if(now != null && back && back.value != null){
          const pc = pctChange(now, back.value);
          if(pc != null) ind.current = pc;
        }
      } else if(ind.fredId === 'ICSA'){
        const avg = rollingAvgLastN('ICSA', 4);
        if(avg != null) ind.current = avg / 1000; // in thousands
      } else {
        const v = lastVal(ind.fredId);
        if(v != null) ind.current = v;
      }
    });

    // Basic logging for key series
    ['T10Y3M','BAMLH0A0HYM2','UMCSENT','M2SL','NFCI','ICSA','SAHMREALTIME','INDPRO','PERMIT']
      .forEach(id => {
        const v = lastVal(id);
        if(v != null){
          console.log(`✅ ${id} loaded from fred_cache.json:`, v);
        } else {
          console.warn(`⚠️ ${id} missing or invalid in fred_cache.json`);
        }
      });

  }catch(err){
    console.error('FRED cache error:', err);
    document.getElementById('cache-badge').textContent = 'FRED cache: error';
  }
}

/**
 * Smoothed macro indicator stress (0–100).
 * Uses safe band, watch band, and danger band.
 */
function scaleIndicator(key, value){
  const ind = INDICATORS[key];
  if(!ind || !Number.isFinite(value)) return null;

  const t = ind.threshold;
  const dir = ind.direction;
  const span = (ind.span && ind.span > 0)
    ? ind.span
    : Math.max(1, Math.abs(t) * 0.5);
  const buffer = (ind.buffer && ind.buffer > 0)
    ? ind.buffer
    : span * 0.5;

  let stress = 0;

  if(dir === 'below'){
    const safeCut = t + buffer;

    if(value >= safeCut){
      stress = 0;
    } else if(value >= t){
      const frac = (safeCut - value) / buffer; // 0..1
      stress = frac * WARN_MAX;
    } else {
      const frac = Math.max(0, Math.min(1, (t - value) / span));
      stress = WARN_MAX + frac * (100 - WARN_MAX);
    }

  } else if(dir === 'above'){
    const safeCut = t - buffer;

    if(value <= safeCut){
      stress = 0;
    } else if(value <= t){
      const frac = (value - safeCut) / buffer; // 0..1
      stress = frac * WARN_MAX;
    } else {
      const frac = Math.max(0, Math.min(1, (value - t) / span));
      stress = WARN_MAX + frac * (100 - WARN_MAX);
    }

  } else {
    return null;
  }

  // Emphasize empirically-strong signals
  if(key === 'YIELD_CURVE' && value <= 0){
    stress = Math.min(100, stress * 1.2);
  }
  if(key === 'SAHM_RULE' && value >= 0.5){
    stress = Math.min(100, stress * 1.3);
  }

  if(!Number.isFinite(stress)) return null;
  if(stress < 0) stress = 0;
  if(stress > 100) stress = 100;

  return stress;
}

/**
 * Smoothed valuation stress mapping (0–100).
 */
function valuationStress(key, val){
  if(!Number.isFinite(val)) return null;

  let s = 0;

  if(key === 'BUFFETT'){
    if(val <= 120){
      s = 0;
    } else if(val <= 150){
      const frac = (val - 120) / (150 - 120);
      s = frac * 40; // 0..40
    } else if(val <= 200){
      const frac = (val - 150) / (200 - 150);
      s = 40 + frac * 60; // 40..100
    } else {
      s = 100;
    }
  } else if(key === 'SHILLER_PE'){
    if(val <= 22){
      s = 0;
    } else if(val <= 30){
      const frac = (val - 22) / (30 - 22);
      s = frac * 40; // 0..40
    } else if(val <= 40){
      const frac = (val - 30) / (40 - 30);
      s = 40 + frac * 60; // 40..100
    } else {
      s = 100;
    }
  } else {
    return null;
  }

  if(s < 0) s = 0;
  if(s > 100) s = 100;
  return s;
}

/**
 * Composite: 70% macro, 30% valuations when both present.
 * If only one block available, use that block directly.
 */
function computeComposite(){
  let macroStress = 0;
  let macroTotalWeight = 0;

  Object.entries(INDICATORS).forEach(([k, ind]) => {
    const stress = scaleIndicator(k, ind.current);
    if(stress !== null && Number.isFinite(stress) && ind.weight){
      macroStress += stress * ind.weight;
      macroTotalWeight += ind.weight;
    }
  });

  let valuationStressSum = 0;
  let valuationTotalWeight = 0;

  Object.entries(VALUATIONS).forEach(([k, v]) => {
    const stress = valuationStress(k, v.current);
    if(stress !== null && Number.isFinite(stress) && v.weight){
      valuationStressSum += stress * v.weight;
      valuationTotalWeight += v.weight;
    }
  });

  if(macroTotalWeight === 0 && valuationTotalWeight === 0){
    return null;
  }

  const macroComponent = macroTotalWeight > 0 ? (macroStress / macroTotalWeight) : null;
  const valuationComponent = valuationTotalWeight > 0 ? (valuationStressSum / valuationTotalWeight) : null;

  let composite = null;

  if(macroComponent !== null && valuationComponent !== null){
    composite = (macroComponent * MACRO_BLOCK_WEIGHT) +
                (valuationComponent * VALUATION_BLOCK_WEIGHT);
  } else if(macroComponent !== null){
    composite = macroComponent;
  } else if(valuationComponent !== null){
    composite = valuationComponent;
  }

  if(composite === null || !Number.isFinite(composite)) return null;
  if(composite < 0) composite = 0;
  if(composite > 100) composite = 100;

  return composite;
}

function derivedRecessionRisk(c){
  if(c == null) return '--';
  if(c < 20) return '<10%';
  if(c < 35) return '10–25%';
  if(c < 50) return '25–40%';
  if(c < 65) return '40–60%';
  if(c < 80) return '60–75%';
  return '75–90%';
}

function derivedValuationRisk(){
  let sum = 0, w = 0;
  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const s = valuationStress(k, v.current);
    if(s != null && v.weight){
      sum += s * v.weight;
      w   += v.weight;
    }
  });
  if(!w) return '--';
  const sc = Math.round(sum / w);
  if(sc < 33) return 'Low';
  if(sc < 66) return 'Moderate';
  return 'High';
}

function derivedLaborStress(){
  const c = INDICATORS.INITIAL_CLAIMS.current;
  const s = INDICATORS.SAHM_RULE.current;
  if(!Number.isFinite(c) || !Number.isFinite(s)) return '--';
  const cs = Math.max(0, Math.min(100, (c - 250) * 0.5));
  const ss = Math.max(0, Math.min(100, s * 200));
  const avg = (cs + ss) / 2;
  if(avg < 30) return 'Low';
  if(avg < 60) return 'Moderate';
  return 'High';
}

/**
 * Indicator cards.
 */
function buildIndicatorElement(key, ind){
  const s = scaleIndicator(key, ind.current);
  let cls = 'indicator';
  if(s != null){
    if(s >= 66) cls += ' danger';
    else if(s >= 33) cls += ' warning';
  }
  const hasVal = Number.isFinite(ind.current);
  const valText = hasVal ? ind.format(ind.current) : '--';

  const thrText = (ind.threshold != null && ind.format)
    ? 'Threshold pivot: ' + ind.format(ind.threshold) +
      (ind.direction === 'below' ? ' (worse below)' : ' (worse above)')
    : '';

  const stressText = (s != null)
    ? ('Stress: ' + Math.round(s) + '/100')
    : 'Stress: --';

  const src = ind.fromFred ? 'Auto from FRED' : 'Manual input';

  let manual = '';
  if(!ind.fromFred && key === 'LEI'){
    manual =
      '<div class="manual-input-row">' +
        '<span>Set latest 6m %Δ for LEI:</span>' +
        '<input class="manual-input" type="number" step="0.1" ' +
        'data-ind-key="'+key+'" value="'+(hasVal ? ind.current : '')+'">' +
      '</div>';
  }

  const div = document.createElement('div');
  div.className = cls;
  div.setAttribute('data-ind-card', key);
  div.innerHTML =
    '<div class="indicator-header">' +
      '<div class="indicator-name">'+ind.label+'</div>' +
      '<div class="indicator-value" data-ind-value="'+key+'">'+valText+'</div>' +
    '</div>' +
    '<div class="indicator-threshold">'+thrText+'</div>' +
    '<div class="indicator-threshold" data-ind-stress="'+key+'">'+stressText+'</div>' +
    '<div class="indicator-threshold">'+ind.desc+'</div>' +
    '<div class="source-tag">'+src+'</div>' +
    manual;
  return div;
}

function renderIndicators(){
  const t1 = document.getElementById('tier1-indicators');
  const t2 = document.getElementById('tier2-indicators');
  t1.innerHTML = '';
  t2.innerHTML = '';

  Object.entries(INDICATORS).forEach(([k,ind]) => {
    const el = buildIndicatorElement(k, ind);
    if(ind.tier === 1) t1.appendChild(el);
    else t2.appendChild(el);
  });

  document.querySelectorAll('.manual-input[data-ind-key]').forEach(inp => {
    inp.addEventListener('input', () => {
      const key = inp.getAttribute('data-ind-key');
      const v = parseFloat(inp.value);
      INDICATORS[key].current = Number.isFinite(v) ? v : null;
      const valEl = document.querySelector('[data-ind-value="'+key+'"]');
      if(valEl){
        valEl.textContent = Number.isFinite(v)
          ? INDICATORS[key].format(v)
          : '--';
      }
      updateDynamic();
    });
  });
}

/**
 * Valuation cards.
 */
function renderValuations(){
  const box = document.getElementById('valuation-indicators');
  box.innerHTML = '';

  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const s = valuationStress(k, v.current);
    let cls = 'indicator';
    if(s != null){
      if(s >= 66) cls += ' danger';
      else if(s >= 33) cls += ' warning';
    }
    const hasVal = Number.isFinite(v.current);
    const valText = hasVal ? v.format(v.current) : '--';
    const stressText = (s != null)
      ? ('Stress: ' + Math.round(s) + '/100')
      : 'Stress: --';

    let dangerLabel = '';
    if(k === 'BUFFETT'){
      dangerLabel = 'Danger band: > 200%';
    }else if(k === 'SHILLER_PE'){
      dangerLabel = 'Danger band: > 30';
    }else{
      dangerLabel = 'Danger band: ' + v.danger;
    }

    const div = document.createElement('div');
    div.className = cls;
    div.setAttribute('data-val-card', k);
    div.innerHTML =
      '<div class="indicator-header">' +
        '<div class="indicator-name">'+v.label+'</div>' +
        '<div class="indicator-value" data-val-value="'+k+'">'+valText+'</div>' +
      '</div>' +
      '<div class="indicator-threshold">'+dangerLabel+'</div>' +
      '<div class="indicator-threshold" data-val-stress="'+k+'">'+stressText+'</div>' +
      '<div class="indicator-threshold">'+v.desc+'</div>' +
      '<div class="source-tag">Manual input</div>' +
      '<div class="manual-input-row">' +
        '<span>Set current reading:</span>' +
        '<input class="manual-input" type="number" step="0.1" ' +
        'data-val-key="'+k+'" value="'+(hasVal ? v.current : '')+'">' +
      '</div>';
    box.appendChild(div);
  });

  document.querySelectorAll('.manual-input[data-val-key]').forEach(inp => {
    inp.addEventListener('input', () => {
      const key = inp.getAttribute('data-val-key');
      const v = parseFloat(inp.value);
      VALUATIONS[key].current = Number.isFinite(v) ? v : null;
      const valEl = document.querySelector('[data-val-value="'+key+'"]');
      if(valEl){
        valEl.textContent = Number.isFinite(v)
          ? VALUATIONS[key].format(v)
          : '--';
      }
      updateDynamic();
    });
  });
}

function syncValuationCurrentBox(){
  const b = VALUATIONS.BUFFETT.current;
  const c = VALUATIONS.SHILLER_PE.current;
  const bEl = document.getElementById('current-buffett-label');
  const cEl = document.getElementById('current-cape-label');

  if(bEl){
    bEl.textContent = Number.isFinite(b)
      ? ('Buffett: ' + b.toFixed(1) + '%')
      : 'Buffett: --';
  }
  if(cEl){
    cEl.textContent = Number.isFinite(c)
      ? ('CAPE: ' + c.toFixed(1))
      : 'CAPE: --';
  }
}

/**
 * Gauge & statuses.
 */
function renderGaugeAndStatus(){
  compositeScore = computeComposite();

  const scoreEl = document.getElementById('composite-score');
  const needle = document.getElementById('needle');
  const fill = document.getElementById('risk-fill');
  const regimeEl = document.getElementById('regime-label');
  const alert = document.getElementById('alert-banner');

  const total = Object.keys(INDICATORS).length + Object.keys(VALUATIONS).length;
  const used =
    Object.keys(INDICATORS).filter(k => Number.isFinite(INDICATORS[k].current)).length +
    Object.keys(VALUATIONS).filter(k => Number.isFinite(VALUATIONS[k].current)).length;

  const coverage = total ? (used / total) : 0;
  document.getElementById('inputs-badge').textContent =
    'Inputs: ' + used + '/' + total + ' populated';
  document.getElementById('quality-display').textContent =
    total ? Math.round(coverage * 100) + '%' : '--';

  if(compositeScore == null){
    scoreEl.textContent = '--';
    fill.style.width = '0%';
    needle.style.transform = 'translateX(-50%) rotate(0deg)';
    regimeEl.textContent = 'COMPOSITE STRESS — insufficient data';
    document.getElementById('recession-risk-display').textContent = '--';
    document.getElementById('valuation-risk-display').textContent = '--';
    document.getElementById('labor-risk-display').textContent = '--';

    let msg = 'No composite yet. Check FRED cache and manual LEI / valuation inputs.';
    if(cacheAgeDays != null && cacheAgeDays > 7){
      msg = 'Data warning: FRED cache is ' + cacheAgeDays.toFixed(1) +
            ' days old. Update fred_cache.json. ' + msg;
    }
    alert.textContent = msg;
    return;
  }

  const v = Math.round(compositeScore);
  scoreEl.textContent = v;
  fill.style.width = v + '%';
  const angle = (v / 100) * 360;
  needle.style.transform = 'translateX(-50%) rotate(' + angle + 'deg)';

  let regime;
  if(v <= 30) regime = 'Low stress regime';
  else if(v <= 50) regime = 'Elevated — monitor';
  else if(v <= 70) regime = 'High — defensive bias';
  else regime = 'Critical regime';

  regimeEl.textContent = 'COMPOSITE STRESS — ' + regime;
  document.getElementById('recession-risk-display').textContent = derivedRecessionRisk(v);
  document.getElementById('valuation-risk-display').textContent = derivedValuationRisk();
  document.getElementById('labor-risk-display').textContent = derivedLaborStress();

  let prefix = '';
  if(cacheAgeDays != null && cacheAgeDays > 7){
    prefix += 'Data warning: FRED cache is ' + cacheAgeDays.toFixed(1) +
              ' days old. Update fred_cache.json. ';
  }
  if(coverage < 0.8){
    prefix += 'Coverage below 80%. Treat composite as tentative. ';
  }

  if(v >= 70){
    alert.innerHTML = prefix + '<strong>Critical:</strong> Composite = ' + v +
      '. Macro + valuations in historical danger cluster.';
  }else if(v >= 50){
    alert.innerHTML = prefix + '<strong>Warning:</strong> Composite = ' + v +
      '. Elevated risk — inspect indicator tiles.';
  }else{
    alert.textContent = prefix +
      'Composite = ' + v +
      '. No classic crash cluster on this configuration; still consider exogenous shocks.';
  }
}

/**
 * Charts.
 */
function renderMarketTrendChart(){
  const ctx = document.getElementById('market-trend').getContext('2d');
  if(charts.trend) charts.trend.destroy();

  const base = compositeScore != null ? compositeScore : 40;
  const labels = ['T-10','T-8','T-6','T-4','T-2','Now'];
  const compData = [0.7,0.8,0.9,0.95,0.98,1].map(f => {
    let x = base * f;
    if(x < 0) x = 0;
    if(x > 100) x = 100;
    return Math.round(x);
  });

  let vSum = 0, vW = 0;
  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const s = valuationStress(k, v.current);
    if(s != null && v.weight){
      vSum += s * v.weight;
      vW   += v.weight;
    }
  });
  const valBase = vW ? (vSum / vW) : 30;
  const valData = [0.75,0.85,0.92,0.96,0.99,1].map(f => {
    let x = valBase * f;
    if(x < 0) x = 0;
    if(x > 100) x = 100;
    return Math.round(x);
  });

  charts.trend = new Chart(ctx, {
    type:'line',
    data:{
      labels,
      datasets:[
        {
          label:'Composite Stress',
          data:compData,
          borderColor:'#6b9eff',
          backgroundColor:'rgba(107,158,255,0.14)',
          tension:0.32,
          fill:true,
          pointRadius:2
        },
        {
          label:'Valuation Stress',
          data:valData,
          borderColor:'#ff6070',
          backgroundColor:'rgba(255,96,112,0.12)',
          tension:0.32,
          fill:true,
          pointRadius:2
        }
      ]
    },
    options:{
      responsive:true,
      plugins:{
        legend:{labels:{color:'#e8eeff',font:{size:9}}},
        title:{
          display:true,
          text:'Stress & Valuation Trajectory (illustrative)',
          color:'#e8eeff',
          font:{size:11}
        }
      },
      scales:{
        y:{
          min:0,
          max:100,
          ticks:{color:'#8b96b0',font:{size:8}},
          grid:{color:'rgba(255,255,255,0.08)'}
        },
        x:{
          ticks:{color:'#8b96b0',font:{size:8}},
          grid:{color:'rgba(255,255,255,0.06)'}
        }
      }
    }
  });
}

function renderRiskRadarChart(){
  const ctx = document.getElementById('risk-radar').getContext('2d');
  if(charts.radar) charts.radar.destroy();

  const labels = [];
  const data = [];

  Object.entries(INDICATORS).forEach(([k,ind]) => {
    const s = scaleIndicator(k, ind.current);
    if(s != null){
      labels.push(ind.label);
      data.push(Math.round(s));
    }
  });

  let vSum = 0, vW = 0;
  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const s = valuationStress(k, v.current);
    if(s != null && v.weight){
      vSum += s * v.weight;
      vW   += v.weight;
    }
  });
  if(vW){
    labels.push('Valuations (Buffett + CAPE)');
    data.push(Math.round(vSum / vW));
  }

  if(!labels.length) return;

  charts.radar = new Chart(ctx, {
    type:'radar',
    data:{
      labels,
      datasets:[{
        label:'Normalized Stress (0–100)',
        data,
        borderColor:'#6b9eff',
        backgroundColor:'rgba(107,158,255,0.18)',
        pointRadius:2
      }]
    },
    options:{
      responsive:true,
      plugins:{legend:{display:false}},
      scales:{
        r:{
          angleLines:{color:'rgba(255,255,255,0.05)'},
          grid:{color:'rgba(255,255,255,0.09)'},
          suggestedMin:0,
          suggestedMax:100,
          ticks:{display:false},
          pointLabels:{color:'#8b96b0',font:{size:7}}
        }
      }
    }
  });
}

function updateInsight(){
  const el = document.getElementById('insight-text');
  if(!el) return;
  const c = compositeScore;
  const vRisk = derivedValuationRisk();

  if(c == null){
    el.textContent = 'No composite yet. Ensure fred_cache.json is fresh and LEI/Buffett/CAPE are populated.';
  } else if(c >= 70 && vRisk === 'High'){
    el.textContent = 'Macro + valuations both extreme: configuration consistent with major drawdown regimes.';
  } else if(c >= 50 && vRisk !== 'Low'){
    el.textContent = 'Elevated macro stress with stretched valuations: risk-reward skewed left.';
  } else if(c < 40 && vRisk === 'High'){
    el.textContent = 'Macro relatively okay but valuations rich: vulnerable to shocks or policy error.';
  } else if(c < 40 && vRisk === 'Low'){
    el.textContent = 'Macro and valuations both moderate vs history: no classic crash cluster here.';
  } else {
    el.textContent = 'Mixed configuration. Use radar and tiles to see what drives the score.';
  }
}

function updateDynamic(){
  renderGaugeAndStatus();
  renderMarketTrendChart();
  renderRiskRadarChart();
  syncValuationCurrentBox();
  updateInsight();
}

function updateAll(){
  renderIndicators();
  renderValuations();
  updateDynamic();
}

document.addEventListener('DOMContentLoaded', () => {
  loadFromFredCache()
    .then(updateAll)
    .catch(err => {
      console.error('Init error:', err);
      updateAll();
    });
});
</script>
