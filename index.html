<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Advanced Economic Crash Radar with predictive analytics and multi-timeframe analysis" />
  <title>Economic Crash Radar Pro</title>

  <style>
    :root{
      --bg:#0a0e1a; --panel:#12182b; --panel-hover:#151d33; --muted:#8b96b0;
      --text:#e8eeff; --accent:#6b9eff; --accent-bright:#8fb4ff;
      --green:#1ec28b; --amber:#ffc247; --red:#ff6070; --orange:#ff8c42;
      --radius:14px; --shadow:0 4px 24px rgba(0,0,0,.3);
      --ring:200px; --ring-m:160px;
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--text);
      font:15px/1.6 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Helvetica,Arial,sans-serif}
    .wrap{max-width:1400px;margin:0 auto;padding:20px 16px 80px}

    header{margin-bottom:24px}
    h1{font-size:clamp(32px,5vw,48px);line-height:1.1;margin:0 0 8px;
      background:linear-gradient(135deg,var(--text),var(--accent-bright));
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .subtitle{color:var(--muted);font-size:15px;margin:8px 0}

    .card{background:var(--panel);border-radius:var(--radius);padding:24px;margin:20px 0;
      box-shadow:var(--shadow),0 0 0 1px rgba(255,255,255,.04) inset;transition:transform .2s,box-shadow .2s}
    .card:hover{transform:translateY(-2px);box-shadow:0 6px 32px rgba(0,0,0,.4)}

    .gauge-container{display:flex;align-items:center;gap:32px;flex-wrap:wrap}
    .gauge-wrap{position:relative;width:var(--ring);height:var(--ring)}
    .multi-ring{position:absolute;inset:0}
    .ring{position:absolute;border-radius:50%;transition:opacity .3s}
    .ring-outer{inset:0;background:conic-gradient(var(--green)0 108deg,var(--amber)108deg 216deg,var(--red)216deg 360deg);opacity:.3}
    .ring-mid{inset:15px;background:conic-gradient(var(--green)0 108deg,var(--amber)108deg 216deg,var(--red)216deg 360deg);opacity:.5}
    .ring-inner{inset:30px;background:conic-gradient(var(--green)0 108deg,var(--amber)108deg 216deg,var(--red)216deg 360deg)}
    .ring::after{content:"";position:absolute;inset:20px;border-radius:50%;background:var(--panel)}
    .needle{position:absolute;inset:0;transition:transform .6s cubic-bezier(.34,1.56,.64,1)}
    .needle::before{content:"";position:absolute;top:50%;left:50%;width:4px;height:45%;
      background:linear-gradient(180deg,var(--accent-bright),var(--accent));
      transform:translateX(-50%) translateY(-100%) rotate(var(--angle,0deg));
      transform-origin:bottom center;border-radius:4px;box-shadow:0 0 12px var(--accent)}
    .needle::after{content:"";position:absolute;top:50%;left:50%;width:16px;height:16px;background:var(--accent-bright);
      border-radius:50%;transform:translate(-50%,-50%);box-shadow:0 0 16px var(--accent),0 0 0 3px var(--panel)}
    .score{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;font-weight:800;font-size:48px;line-height:1}
    .score-label{font-size:12px;font-weight:600;color:var(--muted);margin-top:4px;letter-spacing:.5px}

    .gauge-info h2{font-size:28px;margin:0 0 8px;font-weight:700}
    .confidence{display:inline-flex;align-items:center;gap:8px;background:rgba(107,158,255,.15);padding:6px 12px;border-radius:8px;font-size:13px;font-weight:600;margin-top:8px}
    .confidence-bar{width:60px;height:6px;background:rgba(255,255,255,.1);border-radius:3px;overflow:hidden}
    .confidence-fill{height:100%;background:var(--accent);border-radius:3px;transition:width .3s}

    .pills-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
    .pill{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);padding:14px 16px;border-radius:12px;transition:all .2s;cursor:pointer}
    .pill:hover{background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.12);transform:translateY(-2px)}
    .pill-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
    .pill-title{font-weight:600;font-size:13px}
    .pill-badge{font-size:11px;padding:3px 8px;border-radius:6px;font-weight:600}
    .pill-value{font-size:20px;font-weight:700;margin:4px 0}
    .pill-change{font-size:12px;color:var(--muted);display:flex;align-items:center;gap:4px}
    .badge-fresh{background:rgba(30,194,139,.15);color:var(--green)}
    .badge-stale{background:rgba(255,194,71,.15);color:var(--amber)}
    .badge-old{background:rgba(255,96,112,.15);color:var(--red)}

    .chart-container{position:relative;height:320px;margin:16px 0}
    .chart-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:12px}
    .chart-title{font-size:18px;font-weight:600;margin:0}
    .chart-controls{display:flex;gap:8px}
    .btn-group{display:flex;gap:4px;background:rgba(255,255,255,.03);padding:4px;border-radius:8px}
    .btn{background:transparent;border:none;color:var(--muted);padding:6px 14px;border-radius:6px;cursor:pointer;font-size:13px;font-weight:500;transition:all .2s}
    .btn:hover{color:var(--text);background:rgba(255,255,255,.06)}
    .btn.active{background:var(--accent);color:#fff}

    .tabs{display:flex;gap:8px;border-bottom:2px solid rgba(255,255,255,.06);margin-bottom:20px;overflow-x:auto}
    .tab{background:transparent;border:none;color:var(--muted);padding:12px 20px;cursor:pointer;font-size:14px;font-weight:600;position:relative;white-space:nowrap}
    .tab:hover{color:var(--text)}
    .tab.active{color:var(--accent-bright)}
    .tab.active::after{content:"";position:absolute;bottom:-2px;left:0;right:0;height:2px;background:var(--accent)}
    .tab-content{display:none}
    .tab-content.active{display:block}

    .status{display:inline-flex;align-items:center;gap:8px;padding:8px 14px;border-radius:8px;font-weight:600;font-size:13px}
    .status-dot{width:8px;height:8px;border-radius:50%}

    .heatmap{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px}
    .heat-cell{background:rgba(255,255,255,.03);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,.06)}
    .heat-label{font-size:12px;color:var(--muted)}
    .heat-value{font-size:22px;font-weight:700}
    .bar{height:6px;border-radius:4px;background:rgba(255,255,255,.08);overflow:hidden;margin-top:8px}
    .bar > span{display:block;height:100%;border-radius:4px}

    .audit{font-size:12px;color:var(--muted);margin-top:8px}
    .audit .bad{color:#ff9da6}
    .audit .warn{color:#ffc247}

    .loading{text-align:center;padding:40px;color:var(--muted)}
    .error-state{background:rgba(255,96,112,.1);border:1px solid rgba(255,96,112,.3);padding:20px;border-radius:var(--radius);margin:20px 0}

    @media (max-width:768px){
      .gauge-container{justify-content:center;text-align:center}
      .gauge-wrap{width:var(--ring-m);height:var(--ring-m)}
      .score{font-size:36px}
      .pills-grid{grid-template-columns:1fr}
      .chart-header{flex-direction:column;align-items:flex-start}
    }
  </style>

</head>
<body>
  <div class="wrap">
    <header>
      <h1>⚡ Economic Crash Radar Pro</h1>
      <div class="subtitle">Advanced multi-timeframe market stress analysis with predictive analytics</div>
      <div id="statusBadge"></div>
      <div id="auditBox" class="audit"></div>
    </header>

```
<main id="mainContent">
  <div class="loading">Loading economic data...</div>
</main>
```

  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.1/dist/chartjs-plugin-annotation.min.js"></script>

  <script>
    'use strict';

    // ==================== CONFIGURATION ====================
    const CONFIG = {
      FRED_CACHE_PATH: 'data/fred_cache.json',
      CACHE_TIMEOUT: 10000,
      
      INDICATORS: {
        T10Y3M:          { label:'Yield Curve',         format:v=>v?.toFixed(2),               weight:0.18, cadence:'daily'   },
        CREDIT:          { label:'Credit Spread',       format:v=>v?.toFixed(2),               weight:0.14, cadence:'daily'   },
        UN_SLOPE6:       { label:'Unemployment Δ',      format:v=>v?.toFixed(2),               weight:0.12, cadence:'monthly' },
        DD_12M:          { label:'Market Drawdown',     format:v=>((v??0)*100).toFixed(1)+'%', weight:0.20, cadence:'daily'   },
        NFCI:            { label:'Financial Conditions',format:v=>v?.toFixed(3),               weight:0.12, cadence:'weekly'  },
        VIX_PROXY:       { label:'Volatility Index',    format:v=>v?.toFixed(1),               weight:0.10, cadence:'daily'   },
        RETAIL_MOMENTUM: { label:'Retail Sales Δ',      format:v=>(v*100)?.toFixed(2)+'%',     weight:0.08, cadence:'monthly' },
        SENTIMENT:       { label:'Consumer Confidence', format:v=>v?.toFixed(1),               weight:0.06, cadence:'monthly' }
      },

      FRESH_LIMITS: { 
        daily:   { ok:7,  warn:30 }, 
        weekly:  { ok:7,  warn:30 }, 
        monthly: { ok:30, warn:60 } 
      },

      ZONE_COLORS: {
        green: '#1ec28b',
        amber: '#ffc247',
        red: '#ff6070'
      }
    };

    // ==================== UTILITIES ====================
    const Utils = {
      clamp: (x, min = 0, max = 100) => Math.max(min, Math.min(max, x)),
      
      map01: (val, good, bad) => {
        if (val == null) return 50;
        const denom = bad - good;
        if (Math.abs(denom) < 1e-9) return 50;
        return ((val - good) / denom) * 100;
      },

      zoneOf: score => score <= 30 ? 'green' : (score <= 60 ? 'amber' : 'red'),
      
      heatColor: score => {
        const r = Math.round(255 * (score / 100));
        const g = Math.round(200 * (1 - score / 100));
        return `rgb(${r},${g},80)`;
      },

      safeParseFloat: val => {
        if (val == null || val === '.' || val === 'NaN' || val === '') return null;
        const num = +val;
        return isFinite(num) ? num : null;
      }
    };

    // ==================== DATA SCALING ====================
    const SCALE = {
      T10Y3M:          v => Utils.clamp(Utils.map01(v,  1.0, -2.0)),
      CREDIT:          v => Utils.clamp(Utils.map01(v,  0.30, 1.00)),
      UN_SLOPE6:       v => Utils.clamp(Utils.map01(v,  0.05, 0.50)),
      DD_12M:          v => Utils.clamp(Utils.map01(v,  0.00, -0.20)),
      NFCI:            v => Utils.clamp(Utils.map01(v, -0.80, 0.40)),
      VIX_PROXY:       v => Utils.clamp(Utils.map01(v,  12,  35)),
      RETAIL_MOMENTUM: v => Utils.clamp(Utils.map01(v,  0.03, -0.02)),
      SENTIMENT:       v => Utils.clamp(Utils.map01(v, 110,  70))
    };

    // ==================== DATA LAYER ====================
    class DataService {
      static async loadFredCache() {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), CONFIG.CACHE_TIMEOUT);

        try {
          const res = await fetch(`${CONFIG.FRED_CACHE_PATH}?t=${Date.now()}`, { 
            cache: 'no-store',
            signal: controller.signal
          });
          
          clearTimeout(timeout);
          
          if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          
          const raw = await res.json();
          return this.normalizeCache(raw);
        } catch (err) {
          clearTimeout(timeout);
          if (err.name === 'AbortError') throw new Error('Request timeout');
          throw err;
        }
      }

      static normalizeCache(raw) {
        const out = {};
        
        if (!raw) return out;

        // Direct format: { SERIES_ID: { observations: [...] } }
        const directLike = typeof raw === 'object' && 
          Object.keys(raw).some(k => raw[k] && Array.isArray(raw[k].observations));
        
        if (directLike) return raw;

        // Array format with series property
        if (Array.isArray(raw?.series)) {
          for (const item of raw.series) {
            const id = item?.id || item?.series_id || item?.name;
            if (!id) continue;
            const obs = Array.isArray(item.observations) ? item.observations :
                       Array.isArray(item.data) ? item.data : [];
            out[id] = { observations: obs, fetchedAt: item.fetchedAt };
          }
          return out;
        }

        // Object with series property
        if (raw.series && typeof raw.series === 'object' && !Array.isArray(raw.series)) {
          for (const [id, item] of Object.entries(raw.series)) {
            const obs = Array.isArray(item?.observations) ? item.observations :
                       Array.isArray(item?.data) ? item.data : [];
            out[id] = { observations: obs, fetchedAt: item.fetchedAt };
          }
          return out;
        }

        // Direct array
        if (Array.isArray(raw)) {
          for (const item of raw) {
            const id = item?.id || item?.series_id || item?.name;
            if (!id) continue;
            const obs = Array.isArray(item.observations) ? item.observations :
                       Array.isArray(item.data) ? item.data : [];
            out[id] = { observations: obs, fetchedAt: item.fetchedAt };
          }
        }

        return out;
      }

      static latest(series) {
        const obs = series?.observations || [];
        if (!obs.length) return null;
        const o = obs[obs.length - 1];
        const v = Utils.safeParseFloat(o.value);
        return { value: v, date: o.date };
      }

      static seriesAgeDays(series, fetchedAt) {
        const L = this.latest(series);
        if (!L) return Infinity;
        const d = new Date(L.date + 'T00:00:00Z');
        const ref = new Date(fetchedAt || Date.now());
        return Math.max(0, Math.round((ref - d) / 86400000));
      }
    }

    // ==================== DERIVED SERIES ====================
    class DerivedSeries {
      static deriveUnempSlope6(UNRATE) {
        const obs = UNRATE?.observations || [];
        if (!obs.length) return null;
        
        const byMonth = {};
        for (const o of obs) {
          const v = Utils.safeParseFloat(o.value);
          if (v !== null) byMonth[o.date.slice(0, 7)] = v;
        }
        
        const months = Object.keys(byMonth).sort();
        if (months.length < 7) return null;
        
        const out = [];
        for (let i = 6; i < months.length; i++) {
          const m = months[i], prev = months[i - 6];
          const delta = byMonth[m] - byMonth[prev];
          const [yy, mm] = m.split('-').map(Number);
          const d = new Date(Date.UTC(yy, mm, 0));
          out.push({ date: d.toISOString().slice(0, 10), value: String(delta) });
        }
        
        return { observations: out, fetchedAt: UNRATE.fetchedAt };
      }

      static deriveDrawdown12m(SP500) {
        const obs = SP500?.observations || [];
        if (!obs.length) return null;
        
        const dates = obs.map(o => o.date);
        const vals = obs.map(o => Utils.safeParseFloat(o.value));
        const peak = [];
        
        for (let i = 0; i < vals.length; i++) {
          const start = Math.max(0, i - 252);
          let p = -Infinity;
          for (let j = start; j <= i; j++) {
            if (vals[j] !== null) p = Math.max(p, vals[j]);
          }
          peak.push(p);
        }
        
        const dd = dates.map((d, i) => ({
          date: d,
          value: vals[i] !== null && peak[i] !== -Infinity ? String(vals[i] / peak[i] - 1) : '.'
        }));
        
        return { observations: dd, fetchedAt: SP500.fetchedAt };
      }

      static deriveRetailMomentum(RSAFS) {
        const o = RSAFS?.observations || [];
        if (o.length < 2) return null;
        
        const last = Utils.safeParseFloat(o[o.length - 1].value);
        let prev = null;
        
        for (let i = o.length - 2; i >= 0; i--) {
          const v = Utils.safeParseFloat(o[i].value);
          if (v !== null) {
            prev = v;
            break;
          }
        }
        
        if (prev === null || prev === 0 || last === null) return null;
        
        return {
          observations: [{ date: o[o.length - 1].date, value: String(last / prev - 1) }],
          fetchedAt: RSAFS.fetchedAt
        };
      }
    }

    // ==================== INDICATOR PROCESSOR ====================
    class IndicatorProcessor {
      static mapIndicatorsFromCache(cache) {
        const out = {};
        
        // Direct mappings
        for (const k of Object.keys(CONFIG.INDICATORS)) {
          if (cache[k]) out[k] = cache[k];
        }
        
        // Fallbacks
        if (!out.CREDIT && (cache.BAMLH0A0HYM2 || cache.BAA10YM)) {
          out.CREDIT = cache.BAMLH0A0HYM2 || cache.BAA10YM;
        }
        if (!out.VIX_PROXY && cache.VIXCLS) out.VIX_PROXY = cache.VIXCLS;
        if (!out.SENTIMENT && cache.UMCSENT) out.SENTIMENT = cache.UMCSENT;

        // Derived series
        if (!out.UN_SLOPE6 && cache.UNRATE) {
          out.UN_SLOPE6 = DerivedSeries.deriveUnempSlope6(cache.UNRATE) || 
            { observations: [], fetchedAt: cache.UNRATE.fetchedAt };
        }
        if (!out.DD_12M && cache.SP500) {
          out.DD_12M = DerivedSeries.deriveDrawdown12m(cache.SP500) || 
            { observations: [], fetchedAt: cache.SP500.fetchedAt };
        }
        if (!out.RETAIL_MOMENTUM && cache.RSAFS) {
          out.RETAIL_MOMENTUM = DerivedSeries.deriveRetailMomentum(cache.RSAFS) || 
            { observations: [], fetchedAt: cache.RSAFS.fetchedAt };
        }
        
        return out;
      }

      static freshnessPenalty(days, cadence, isCalm = false) {
        const lim = CONFIG.FRESH_LIMITS[cadence] || CONFIG.FRESH_LIMITS.daily;
        const ok = isCalm ? Math.floor(lim.ok / 2) : lim.ok;
        const warn = isCalm ? Math.floor(lim.warn / 2) : lim.warn;
        
        if (days <= ok) return 1.00;
        if (days <= warn) return 0.85;
        return 0.70;
      }

      static computeComposite(dataMap, isCalm) {
        let num = 0, den = 0;
        const parts = [];
        
        for (const [k, cfg] of Object.entries(CONFIG.INDICATORS)) {
          const s = dataMap[k];
          const obs = s?.observations || [];
          if (!obs.length) continue;
          
          const L = DataService.latest(s);
          if (!L || L.value === null) continue;

          const days = DataService.seriesAgeDays(s, s.fetchedAt);
          const lim = CONFIG.FRESH_LIMITS[cfg.cadence] || CONFIG.FRESH_LIMITS.daily;
          const badge = days <= lim.ok ? { cls: 'badge-fresh', txt: 'Fresh' } :
                       days <= lim.warn ? { cls: 'badge-stale', txt: 'Stale' } :
                       { cls: 'badge-old', txt: 'Old' };

          const scaled = SCALE[k](L.value);
          const w = cfg.weight * this.freshnessPenalty(days, cfg.cadence, isCalm);
          
          if (Number.isFinite(scaled) && Number.isFinite(w)) {
            num += scaled * w;
            den += w;
          }

          let change = null;
          if (obs.length >= 2) {
            const a = Utils.safeParseFloat(obs[obs.length - 1].value);
            const b = Utils.safeParseFloat(obs[obs.length - 2].value);
            if (a !== null && b !== null) change = a - b;
          }

          parts.push({
            key: k,
            label: cfg.label,
            valueDisp: cfg.format?.(L.value) ?? L.value,
            change,
            freshClass: badge.cls,
            freshTxt: badge.txt,
            scaled,
            w,
            obs
          });
        }
        
        return { parts, num, den };
      }
    }

    // ==================== ANALYTICS ====================
    class Analytics {
      static complacencyPenalty(dataMap) {
        const vix = dataMap.VIX_PROXY?.observations || [];
        const hy = dataMap.CREDIT?.observations || [];
        const dd = dataMap.DD_12M?.observations || [];
        
        if (vix.length < 22 || hy.length < 1 || dd.length < 1) return 0;

        let streak = 0;
        for (let i = vix.length - 1; i >= 0 && streak < 60; i--) {
          const val = Utils.safeParseFloat(vix[i].value);
          if (val !== null && val <= 13) streak++;
          else break;
        }
        const vixScore = Math.min(1, streak / 30);

        const hyLast = Utils.safeParseFloat(hy[hy.length - 1].value);
        const spreadTight = hyLast !== null && hyLast <= 0.35 ? 1 : 0;

        const ddLast = Utils.safeParseFloat(dd[dd.length - 1].value);
        const shallowDD = ddLast !== null && ddLast >= -0.05 ? 1 : 0;

        const raw = 0.5 * vixScore + 0.3 * spreadTight + 0.2 * shallowDD;
        return Math.round(15 * raw);
      }

      static inflationDriftPenalty(cache) {
        const CPI = cache.CPI_YOY || cache.CPIAUCSL_YOY || null;
        if (!CPI?.observations?.length) return 0;
        
        const o = CPI.observations;
        const last = Utils.safeParseFloat(o[o.length - 1].value);
        if (last === null) return 0;
        
        if (last <= 2.5) return 0;
        if (last <= 3.5) return Math.round(1 + 2 * (last - 2.5));
        return Math.min(6, Math.round(2 + 2 * (last - 3.5)));
      }

      static compositeMomentum(hist, lookbackDays) {
        if (!hist?.length) return 0;
        const n = hist.length;
        const a = Math.max(0, n - 1 - lookbackDays);
        const b = n - 1;
        const da = hist[a]?.value ?? hist[0].value;
        const db = hist[b]?.value ?? hist[n - 1].value;
        return db - da;
      }

      static horizonRiskSmart(composite, hist) {
        const m20 = this.compositeMomentum(hist, 20);
        const m60 = this.compositeMomentum(hist, 60);
        const m120 = this.compositeMomentum(hist, 120);
        
        const base = x => 1 / (1 + Math.exp(-(x - 50) / 10));
        const p1 = base(composite) * (0.70 + 0.02 * m20);
        const p3 = base(composite) * (0.95 + 0.015 * m60);
        const p6 = base(composite) * (1.20 + 0.010 * m120);
        
        const clip = p => Math.round(Math.max(5, Math.min(95, 100 * p)));
        return { p1: clip(p1), p3: clip(p3), p6: clip(p6) };
      }

      static buildCompositeHistory(dataMap) {
        const keysForHist = ['DD_12M', 'VIX_PROXY', 'T10Y3M', 'CREDIT', 'NFCI'];
        const allDates = new Set();
        
        for (const k of keysForHist) {
          (dataMap[k]?.observations || []).forEach(o => allDates.add(o.date));
        }
        
        const dates = Array.from(allDates).sort();
        
        return dates.map(date => {
          let n = 0, d = 0;
          
          for (const [k, cfg] of Object.entries(CONFIG.INDICATORS)) {
            const s = dataMap[k];
            if (!s) continue;
            
            const obs = s.observations;
            let v = null;
            
            for (let i = obs.length - 1; i >= 0; i--) {
              if (obs[i].date <= date) {
                const vv = Utils.safeParseFloat(obs[i].value);
                if (vv !== null) {
                  v = vv;
                  break;
                }
              }
