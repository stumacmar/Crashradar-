<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Economic Crash Radar Pro v7</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg:#0a0e1a;
      --panel:#12182b;
      --text:#e8eeff;
      --muted:#8b96b0;
      --accent:#6b9eff;
      --accent-soft:#8fb4ff;
      --green:#1ec28b;
      --amber:#ffc247;
      --red:#ff6070;
      --radius-lg:16px;
      --shadow-soft:0 8px 24px rgba(0,0,0,0.45);
      --font-main:-apple-system,BlinkMacSystemFont,"Segoe UI",system-ui,sans-serif;
    }

    *{margin:0;padding:0;box-sizing:border-box;}

    body{
      background:var(--bg);
      color:var(--text);
      font:15px/1.6 var(--font-main);
      -webkit-font-smoothing:antialiased;
      padding:18px 12px 40px;
    }

    .container{max-width:1440px;margin:0 auto;}
    .header{text-align:center;margin-bottom:18px;}

    h1{
      font-size:clamp(30px,6vw,46px);
      font-weight:800;
      margin-bottom:6px;
      background:linear-gradient(135deg,var(--text),var(--accent-soft));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
    }

    .subtitle{
      color:var(--muted);
      font-size:0.95rem;
    }

    .meta-badges{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:6px;
      margin-top:8px;
      font-size:0.7rem;
      color:var(--muted);
    }

    .badge{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.02);
    }

    .alert-banner{
      margin:16px auto 18px;
      padding:10px 12px;
      max-width:900px;
      border-radius:10px;
      background:linear-gradient(135deg,rgba(107,158,255,0.08),rgba(139,187,255,0.02));
      border:1px solid rgba(107,158,255,0.25);
      font-size:0.8rem;
      color:var(--text);
    }

    .dashboard{
      display:grid;
      grid-template-columns:280px 1fr;
      gap:16px;
      align-items:flex-start;
    }

    .sidebar{
      background:var(--panel);
      border-radius:var(--radius-lg);
      padding:16px 14px 14px;
      box-shadow:var(--shadow-soft);
    }

    .main-content{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:14px;
    }

    .card{
      background:var(--panel);
      border-radius:var(--radius-lg);
      padding:14px 12px 12px;
      box-shadow:var(--shadow-soft);
    }

    .card-title{
      font-size:1rem;
      font-weight:700;
      color:var(--accent-soft);
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:8px;
    }
    .card-title .icon{font-size:1.1rem;}

    .gauge-container{text-align:center;margin-bottom:8px;}
    .gauge{
      position:relative;
      width:190px;
      height:190px;
      margin:0 auto;
    }
    .gauge-background{
      position:absolute;
      inset:0;
      border-radius:50%;
      background:conic-gradient(
        var(--green) 0deg 108deg,
        var(--amber) 108deg 216deg,
        var(--red) 216deg 360deg
      );
      opacity:0.28;
    }
    .gauge-center{
      position:absolute;
      top:10%;
      left:10%;
      width:80%;
      height:80%;
      border-radius:50%;
      background:var(--panel);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    .gauge-score{
      font-size:2.4rem;
      font-weight:800;
    }
    .gauge-label{
      font-size:0.7rem;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.08em;
      margin-top:2px;
      text-align:center;
    }
    .gauge-needle{
      position:absolute;
      bottom:50%;
      left:50%;
      width:3px;
      height:46%;
      background:var(--accent);
      transform-origin:bottom center;
      transform:translateX(-50%) rotate(0deg);
      border-radius:4px 4px 0 0;
      transition:transform 0.9s ease;
    }

    .risk-meter{margin-top:6px;}
    .risk-bar{
      height:6px;
      border-radius:4px;
      background:rgba(255,255,255,0.1);
      overflow:hidden;
    }
    .risk-fill{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,var(--green),var(--amber),var(--red));
      transition:width 0.8s ease;
    }
    .risk-labels{
      display:flex;
      justify-content:space-between;
      margin-top:4px;
      font-size:0.65rem;
      color:var(--muted);
    }

    .status-grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px;
      margin-top:10px;
    }
    .status-item{
      padding:7px 6px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      font-size:0.7rem;
    }
    .status-label{
      color:var(--muted);
      font-size:0.66rem;
    }
    .status-value{
      font-weight:700;
      font-size:0.95rem;
      margin-top:1px;
    }

    .indicator-grid{
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(220px,1fr));
      gap:7px;
      margin-top:4px;
    }
    .indicator{
      padding:7px 7px 6px;
      background:rgba(255,255,255,0.03);
      border-radius:8px;
      border-left:3px solid var(--green);
      font-size:0.7rem;
      cursor:pointer;
      transition:all 0.2s ease;
      position:relative;
    }
    .indicator:hover {
      background:rgba(255,255,255,0.05);
      transform:translateY(-1px);
    }
    .indicator.warning{border-left-color:var(--amber);}
    .indicator.danger{border-left-color:var(--red);}
    .indicator.expanded {
      grid-column:1 / -1;
      background:rgba(255,255,255,0.04);
    }

    .indicator-header{
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:baseline;
      margin-bottom:2px;
    }
    .indicator-name{
      font-weight:600;
      font-size:0.78rem;
    }
    .indicator-value{
      font-weight:700;
      font-size:0.9rem;
    }
    .indicator-threshold{
      color:var(--muted);
      font-size:0.62rem;
      margin-top:1px;
    }
    .source-tag{
      display:inline-block;
      margin-top:3px;
      padding:2px 5px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.14);
      font-size:0.58rem;
      color:var(--muted);
    }

    .manual-input-row{
      display:flex;
      flex-direction:column;
      gap:3px;
      margin-top:4px;
      font-size:0.6rem;
    }
    .manual-input-row span{
      color:var(--muted);
      font-size:0.62rem;
    }
    .manual-input{
      width:100%;
      padding:8px 8px;
      min-height:44px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.5);
      color:var(--text);
      font-size:0.75rem;
      outline:none;
    }
    .manual-input:focus{
      border-color:var(--accent);
      box-shadow:0 0 4px var(--accent);
    }

    .valuation-comparison{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(150px,1fr));
      gap:6px;
      margin-top:8px;
      font-size:0.68rem;
    }
    .valuation-item{
      padding:6px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      text-align:center;
    }
    .valuation-item.current{
      border:1px solid var(--red);
      background:rgba(255,96,112,0.05);
    }
    .valuation-title{
      font-weight:600;
      margin-bottom:2px;
    }
    .valuation-metric{margin:1px 0;}
    .valuation-outcome{
      margin-top:2px;
      color:var(--muted);
    }

    .insight-card{
      margin-top:6px;
      padding:6px 7px;
      border-radius:8px;
      background:linear-gradient(135deg,rgba(107,158,255,0.10),rgba(10,14,26,1));
      border:1px solid rgba(107,158,255,0.25);
      font-size:0.7rem;
    }
    .chart-container{margin-top:4px;}

    .history-grid{
      margin-top:6px;
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
      gap:5px;
      font-size:0.66rem;
    }
    .history-item{
      padding:5px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
    }
    .history-title{
      font-weight:600;
      margin-bottom:1px;
      font-size:0.7rem;
    }

    /* New styles for enhancements */
    .data-source-indicator {
      display:flex;
      align-items:center;
      gap:4px;
      margin-top:2px;
    }
    
    .data-source-dot {
      width:6px;
      height:6px;
      border-radius:50%;
      display:inline-block;
    }
    
    .data-source-auto {
      background-color:var(--green);
    }
    
    .data-source-manual {
      background-color:var(--amber);
    }
    
    .data-source-missing {
      background-color:var(--muted);
    }

    .data-source-stale {
      background-color:var(--red);
    }
    
    .refresh-controls {
      display:flex;
      gap:8px;
      margin-top:8px;
      justify-content:center;
    }
    
    .btn {
      padding:6px 12px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.05);
      color:var(--text);
      font-size:0.7rem;
      cursor:pointer;
      transition:all 0.2s ease;
    }
    
    .btn:hover {
      background:rgba(255,255,255,0.1);
    }
    
    .btn-primary {
      background:var(--accent);
      border-color:var(--accent);
    }
    
    .btn-primary:hover {
      background:var(--accent-soft);
    }
    
    .export-section {
      margin-top:12px;
      padding-top:12px;
      border-top:1px solid rgba(255,255,255,0.1);
    }
    
    .export-section h3 {
      font-size:0.8rem;
      margin-bottom:6px;
      color:var(--accent-soft);
    }
    
    .export-options {
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    
    .export-btn {
      padding:4px 8px;
      font-size:0.65rem;
    }
    
    .loading-overlay {
      position:fixed;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:rgba(10,14,26,0.9);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      z-index:1000;
      opacity:0;
      pointer-events:none;
      transition:opacity 0.3s ease;
    }
    
    .loading-overlay.active {
      opacity:1;
      pointer-events:all;
    }
    
    .loading-spinner {
      width:40px;
      height:40px;
      border:4px solid rgba(255,255,255,0.1);
      border-left:4px solid var(--accent);
      border-radius:50%;
      animation:spin 1s linear infinite;
      margin-bottom:16px;
    }
    
    .loading-text {
      font-size:0.9rem;
      color:var(--text);
    }
    
    @keyframes spin {
      0% { transform:rotate(0deg); }
      100% { transform:rotate(360deg); }
    }
    
    .indicator-tooltip {
      position:absolute;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.2);
      border-radius:6px;
      padding:8px;
      font-size:0.7rem;
      max-width:250px;
      z-index:100;
      box-shadow:0 4px 12px rgba(0,0,0,0.5);
      pointer-events:none;
      opacity:0;
      transition:opacity 0.2s ease;
    }
    
    .indicator-tooltip.active {
      opacity:1;
    }

    /* History chart styles */
    .indicator-history {
      margin-top:10px;
      display:none;
    }
    
    .indicator.expanded .indicator-history {
      display:block;
    }
    
    .history-chart-container {
      height:160px;
      margin-top:8px;
    }
    
    .history-period-selector {
      display:flex;
      gap:6px;
      margin-bottom:8px;
      justify-content:center;
    }
    
    .period-btn {
      padding:3px 8px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(255,255,255,0.03);
      color:var(--muted);
      font-size:0.6rem;
      cursor:pointer;
      transition:all 0.2s ease;
    }
    
    .period-btn.active {
      background:var(--accent);
      color:var(--text);
      border-color:var(--accent);
    }
    
    .history-stats {
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:6px;
      margin-top:8px;
      font-size:0.65rem;
    }
    
    .history-stat {
      padding:4px;
      background:rgba(255,255,255,0.02);
      border-radius:4px;
      text-align:center;
    }
    
    .history-stat-value {
      font-weight:700;
      font-size:0.75rem;
      margin-top:2px;
    }
    
    .history-stat-label {
      color:var(--muted);
      font-size:0.55rem;
    }

    .no-data-message {
      text-align:center;
      color:var(--muted);
      font-size:0.7rem;
      padding:20px;
    }

    @media(max-width:900px){
      body{padding:14px 8px 26px;}
      .dashboard{grid-template-columns:1fr;}
      .main-content{grid-template-columns:1fr;}
      .sidebar{order:-1;}
      .export-options{flex-direction:column;}
      .history-stats{grid-template-columns:repeat(2,1fr);}
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>âš¡ Economic Crash Radar Pro v7</h1>
    <div class="subtitle">
      10 macro indicators (9 auto via FRED, 1 manual) + 2 valuations. Composite with smoothed stress bands (no binary cliffs).
    </div>
    <div class="meta-badges">
      <div class="badge" id="cache-badge">FRED cache: not loaded</div>
      <div class="badge">Manual: LEI 6m Î”, Buffett, CAPE</div>
      <div class="badge">Auto: Curve, HY, NFCI, UMich, M2, INDPRO, Permits, Claims, Sahm</div>
      <div class="badge" id="inputs-badge">Inputs: 0/12 populated</div>
    </div>
    <div class="refresh-controls">
      <button class="btn btn-primary" id="refresh-data">Refresh Data</button>
      <button class="btn" id="reset-inputs">Reset Inputs</button>
      <button class="btn" id="show-help">Help & Documentation</button>
    </div>
  </div>

  <div class="alert-banner" id="alert-banner">
    Composite = 70% macro block + 30% valuation block when both available; otherwise uses whichever block is populated.
  </div>

  <div class="dashboard">
    <!-- SIDEBAR -->
    <div class="sidebar">
      <div class="gauge-container">
        <div class="gauge">
          <div class="gauge-background"></div>
          <div class="gauge-center">
            <div class="gauge-score" id="composite-score">--</div>
            <div class="gauge-label" id="regime-label">COMPOSITE STRESS</div>
          </div>
          <div class="gauge-needle" id="needle"></div>
        </div>
        <div class="risk-meter">
          <div class="risk-bar">
            <div class="risk-fill" id="risk-fill"></div>
          </div>
          <div class="risk-labels">
            <span>Low (0-30)</span>
            <span>Med (30-50)</span>
            <span>High (50-70)</span>
            <span>Critical (70-100)</span>
          </div>
        </div>
      </div>
      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">Recession Probability (12â€“18m)</div>
          <div class="status-value" id="recession-risk-display">--</div>
          <div class="indicator-threshold">Bucketed from composite.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Valuation Risk</div>
          <div class="status-value" id="valuation-risk-display">--</div>
          <div class="indicator-threshold">Buffett + CAPE stress.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Labor Market Stress</div>
          <div class="status-value" id="labor-risk-display">--</div>
          <div class="indicator-threshold">Claims + Sahm.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Data Coverage</div>
          <div class="status-value" id="quality-display">--</div>
          <div class="indicator-threshold">Filled indicators / total.</div>
        </div>
      </div>
      
      <div class="export-section">
        <h3>Export & Share</h3>
        <div class="export-options">
          <button class="btn export-btn" id="export-pdf">PDF Report</button>
          <button class="btn export-btn" id="export-csv">CSV Data</button>
          <button class="btn export-btn" id="export-snapshot">Snapshot</button>
          <button class="btn export-btn" id="share-link">Share Link</button>
        </div>
      </div>
    </div>

    <!-- MAIN -->
    <div class="main-content">
      <div class="card">
        <div class="card-title"><span class="icon">ðŸ“Š</span>Tier 1 Leading Indicators</div>
        <div class="indicator-grid" id="tier1-indicators"></div>
      </div>

      <div class="card">
        <div class="card-title"><span class="icon">ðŸ“ˆ</span>Tier 2 Confirming Indicators</div>
        <div class="indicator-grid" id="tier2-indicators"></div>
      </div>

      <div class="card">
        <div class="card-title"><span class="icon">ðŸ’°</span>Valuation Indicators</div>
        <div class="indicator-grid" id="valuation-indicators"></div>

        <div class="valuation-comparison">
          <div class="valuation-item">
            <div class="valuation-title">2000 Dot-com</div>
            <div class="valuation-metric">CAPE â‰ˆ 44</div>
            <div class="valuation-metric">Buffett â‰ˆ 140â€“160%</div>
            <div class="valuation-outcome">Severe drawdown.</div>
          </div>
          <div class="valuation-item">
            <div class="valuation-title">2007 Pre-GFC</div>
            <div class="valuation-metric">CAPE â‰ˆ 27</div>
            <div class="valuation-metric">Buffett â‰ˆ 105%</div>
            <div class="valuation-outcome">Crisis.</div>
          </div>
          <div class="valuation-item">
            <div class="valuation-title">2021 Peak</div>
            <div class="valuation-metric">CAPE â‰ˆ 38</div>
            <div class="valuation-metric">Buffett â‰ˆ 195%</div>
            <div class="valuation-outcome">2022 correction.</div>
          </div>
          <div class="valuation-item current">
            <div class="valuation-title">Current (your inputs)</div>
            <div class="valuation-metric" id="current-buffett-label">Buffett: --</div>
            <div class="valuation-metric" id="current-cape-label">CAPE: --</div>
            <div class="valuation-outcome">Reflects manual entries.</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title"><span class="icon">ðŸ•’</span>History, Radar & Prior Recessions</div>
        <div class="chart-container">
          <canvas id="market-trend" height="130"></canvas>
        </div>
        <div class="chart-container">
          <canvas id="risk-radar" height="140"></canvas>
        </div>
        <div class="insight-card">
          <strong>Insight:</strong>
          <span id="insight-text">
            Once populated, this compares today's configuration to prior stress regimes.
          </span>
        </div>
        <div class="history-grid">
          <div class="history-item">
            <div class="history-title">1973â€“75 / early 80s</div>
            <div>Curve inversion + energy shocks + weak leads.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2000â€“02</div>
            <div>Extreme valuations, tightening, growth rollover.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2007â€“09</div>
            <div>Housing + credit + inversion aligned.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2020</div>
            <div>External shock; indicator behavior distinct.</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loading-overlay">
  <div class="loading-spinner"></div>
  <div class="loading-text" id="loading-text">Loading data...</div>
</div>

<!-- Tooltip -->
<div class="indicator-tooltip" id="indicator-tooltip"></div>

<script>
'use strict';

const MACRO_BLOCK_WEIGHT = 0.70;
const VALUATION_BLOCK_WEIGHT = 0.30;
const WARN_MAX = 30;

let cacheAgeDays = null;
let lastUpdateTime = null;
let expandedIndicator = null;
let historicalData = {};
let indicatorCharts = {};

const INDICATORS = {
  LEI: {
    tier:1,
    label:'Conference Board LEI 6m %Î”',
    weight:0.15,
    threshold:-3.5,
    direction:'below',
    span:3.0,
    fromFred:false,
    fredId:null,
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(1) + '%',
    desc:'Manual. 6m % change in LEI. â‰¤ -3.5% has preceded most post-1960 recessions.',
    tooltip:'The Conference Board Leading Economic Index (LEI) 6-month percent change. A value â‰¤ -3.5% has historically preceded most recessions since 1960.'
  },
  YIELD_CURVE: {
    tier:1,
    label:'Yield Curve (10yâ€“3m)',
    weight:0.12,
    threshold:0.0,
    direction:'below',
    span:1.0,
    fromFred:true,
    fredId:'T10Y3M',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(2) + ' pp',
    desc:'10yâ€“3m spread. Inversions (â‰¤0) are classic recession leads.',
    tooltip:'10-year minus 3-month Treasury yield spread. Inversions (â‰¤0) have preceded most US recessions since 1950.'
  },
  CREDIT_SPREAD: {
    tier:1,
    label:'HY Credit Spread',
    weight:0.10,
    threshold:5.0,
    direction:'above',
    span:3.0,
    fromFred:true,
    fredId:'BAMLH0A0HYM2',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(2) + ' pp',
    desc:'US HY OAS. >5% = stress, >8% = crisis-like conditions.',
    tooltip:'High-yield corporate bond option-adjusted spread. >5% indicates financial stress; >8% signals crisis-like conditions.'
  },
  FIN_STRESS: {
    tier:1,
    label:'Financial Stress (NFCI)',
    weight:0.08,
    threshold:0.0,
    direction:'above',
    span:0.5,
    fromFred:true,
    fredId:'NFCI',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(2),
    desc:'Chicago Fed NFCI. >0 indicates tighter-than-average conditions.',
    tooltip:'Chicago Fed National Financial Conditions Index. Positive values indicate tighter-than-average financial conditions.'
  },
  CONSUMER_SENTIMENT: {
    tier:1,
    label:'UMich Sentiment',
    weight:0.08,
    threshold:60.0,
    direction:'below',
    span:25.0,
    fromFred:true,
    fredId:'UMCSENT',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(1),
    desc:'Deep pessimism. Sustained <60 readings cluster around recessions.',
    tooltip:'University of Michigan Consumer Sentiment Index. Sustained readings <60 typically cluster around recessions.'
  },
  M2_GROWTH: {
    tier:1,
    label:'M2 Growth YoY',
    weight:0.08,
    threshold:0.0,
    direction:'below',
    span:6.0,
    fromFred:true,
    fredId:'M2SL',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(1) + '%',
    desc:'YoY growth from M2SL. â‰¤0% is historically rare and restrictive.',
    tooltip:'Year-over-year M2 money supply growth. â‰¤0% is historically rare and indicates restrictive monetary conditions.'
  },
  INDUSTRIAL_PRODUCTION: {
    tier:2,
    label:'Industrial Production YoY',
    weight:0.07,
    threshold:0.0,
    direction:'below',
    span:5.0,
    fromFred:true,
    fredId:'INDPRO',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(1) + '%',
    desc:'YoY change. Sustained contraction confirms downturn.',
    tooltip:'Year-over-year industrial production growth. Sustained contraction confirms broader economic downturn.'
  },
  BUILDING_PERMITS: {
    tier:2,
    label:'Building Permits 6m %Î”',
    weight:0.07,
    threshold:-10.0,
    direction:'below',
    span:10.0,
    fromFred:true,
    fredId:'PERMIT',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(1) + '%',
    desc:'6m % change. Sharp drops lead housing & broader weakness.',
    tooltip:'6-month percent change in building permits. Sharp drops typically lead housing market weakness and broader economic slowdown.'
  },
  INITIAL_CLAIMS: {
    tier:2,
    label:'Initial Claims 4wk MA (k)',
    weight:0.08,
    threshold:325,
    direction:'above',
    span:150,
    fromFred:true,
    fredId:'ICSA',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => Math.round(v) + 'k',
    desc:'4-week avg in thousands. >325k consistent with labor market stress.',
    tooltip:'4-week moving average of initial jobless claims in thousands. >325k is consistent with labor market stress.'
  },
  SAHM_RULE: {
    tier:2,
    label:'Sahm Rule (pp)',
    weight:0.07,
    threshold:0.50,
    direction:'above',
    span:0.5,
    fromFred:true,
    fredId:'SAHMREALTIME',
    current:null,
    lastDate:null,
    isStale:false,
    format:v => v.toFixed(2),
    desc:'â‰¥0.50 triggers real-time recession signal.',
    tooltip:'Sahm Rule Recession Indicator. A reading â‰¥0.50 percentage points triggers a real-time recession signal.'
  }
};

const VALUATIONS = {
  BUFFETT: {
    label:'Buffett Indicator (MktCap/GDP)',
    weight:0.50,
    danger:200,
    current:null,
    format:v => v.toFixed(1) + '%',
    desc:'>150% stretched; >200% historically extreme.',
    tooltip:'Total stock market capitalization to GDP ratio. >150% indicates stretched valuations; >200% is historically extreme.'
  },
  SHILLER_PE: {
    label:'Shiller CAPE',
    weight:0.50,
    danger:30,
    current:null,
    format:v => v.toFixed(1),
    desc:'>25 elevated; >30 associated with poor long-run returns.',
    tooltip:'Cyclically Adjusted Price-to-Earnings ratio. >25 indicates elevated valuations; >30 is associated with poor long-term returns.'
  }
};

let charts = { trend:null, radar:null };
let compositeScore = null;

/* ---------- Overlay ---------- */
function showLoading(message = 'Loading data...') {
  const overlay = document.getElementById('loading-overlay');
  const text = document.getElementById('loading-text');
  if (!overlay || !text) return;
  text.textContent = message;
  overlay.classList.add('active');
}

function hideLoading() {
  const overlay = document.getElementById('loading-overlay');
  if (!overlay) return;
  overlay.classList.remove('active');
}

/* ---------- Tooltip ---------- */
function showTooltip(content, x, y) {
  const tooltip = document.getElementById('indicator-tooltip');
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
  tooltip.classList.add('active');
}

function hideTooltip() {
  const tooltip = document.getElementById('indicator-tooltip');
  if (!tooltip) return;
  tooltip.classList.remove('active');
}

/* ---------- Time-series helpers ---------- */
function calculateYoYGrowth(observations) {
  const result = [];
  if (!Array.isArray(observations)) return result;

  for (let i = 12; i < observations.length; i++) {
    const current = parseFloat(observations[i].value);
    const yearAgo = parseFloat(observations[i - 12].value);
    if (!isNaN(current) && !isNaN(yearAgo) && yearAgo !== 0) {
      const growth = ((current - yearAgo) / yearAgo) * 100;
      result.push({ date: observations[i].date, value: growth });
    }
  }
  return result;
}

function calculateRollingPercentChange(observations, months) {
  const result = [];
  if (!Array.isArray(observations) || !Number.isFinite(months) || months <= 0) return result;

  for (let i = months; i < observations.length; i++) {
    const current = parseFloat(observations[i].value);
    const periodAgo = parseFloat(observations[i - months].value);
    if (!isNaN(current) && !isNaN(periodAgo) && periodAgo !== 0) {
      const change = ((current - periodAgo) / periodAgo) * 100;
      result.push({ date: observations[i].date, value: change });
    }
  }
  return result;
}

function calculateMovingAverage(observations, periods) {
  const result = [];
  if (!Array.isArray(observations) || !Number.isFinite(periods) || periods <= 0) return result;

  for (let i = periods - 1; i < observations.length; i++) {
    let sum = 0;
    let count = 0;
    for (let j = 0; j < periods; j++) {
      const value = parseFloat(observations[i - j].value);
      if (!isNaN(value)) {
        sum += value;
        count++;
      }
    }
    if (count === periods) {
      result.push({ date: observations[i].date, value: sum / periods / 1000 }); // thousands
    }
  }
  return result;
}

/* ---------- Single pipeline for indicator series ---------- */
function processSeriesForIndicator(indicator, seriesData) {
  if (!seriesData || !Array.isArray(seriesData.observations)) return [];
  const observations = seriesData.observations;

  if (indicator.fredId === 'M2SL') {
    return calculateYoYGrowth(observations);
  } else if (indicator.fredId === 'INDPRO') {
    return calculateYoYGrowth(observations);
  } else if (indicator.fredId === 'PERMIT') {
    return calculateRollingPercentChange(observations, 6);
  } else if (indicator.fredId === 'ICSA') {
    return calculateMovingAverage(observations, 4);
  }
  // Raw level
  return observations
    .map(obs => ({ date: obs.date, value: parseFloat(obs.value) }))
    .filter(obs => !isNaN(obs.value));
}

/* ---------- Toggle expansion ---------- */
function toggleIndicatorExpansion(key, type = 'indicator') {
  const selector = type === 'valuation'
    ? `[data-val-card="${key}"]`
    : `[data-ind-card="${key}"]`;
  const element = document.querySelector(selector);
  if (!element) return;

  if (expandedIndicator === key) {
    element.classList.remove('expanded');
    expandedIndicator = null;
    if (indicatorCharts[key]) {
      try { indicatorCharts[key].destroy(); } catch(e) { console.warn('Chart destroy failed', e); }
      delete indicatorCharts[key];
    }
    return;
  }

  // Collapse previous
  if (expandedIndicator) {
    const prevSelector = type === 'valuation'
      ? `[data-val-card="${expandedIndicator}"]`
      : `[data-ind-card="${expandedIndicator}"]`;
    const prevElement = document.querySelector(prevSelector);
    if (prevElement) prevElement.classList.remove('expanded');
    if (indicatorCharts[expandedIndicator]) {
      try { indicatorCharts[expandedIndicator].destroy(); } catch(e) {}
      delete indicatorCharts[expandedIndicator];
    }
  }

  element.classList.add('expanded');
  expandedIndicator = key;
  loadAndRenderIndicatorHistory(key, type, '12M');
}

/* ---------- Load historical data ---------- */
async function loadHistoricalData(fredId, indicator) {
  if (!fredId || !indicator) return null;

  if (historicalData[fredId]) {
    return historicalData[fredId];
  }

  try {
    const response = await fetch('data/fred_cache.json');
    if (!response.ok) {
      console.error('Historical fetch error:', response.status);
      return null;
    }
    const data = await response.json();
    if (!data || !data.series || !data.series[fredId]) {
      console.error('Historical series missing for', fredId);
      return null;
    }

    const seriesData = data.series[fredId];
    const processed = processSeriesForIndicator(indicator, seriesData);
    historicalData[fredId] = processed;
    return processed;
  } catch (err) {
    console.error('loadHistoricalData error for', fredId, err);
    return null;
  }
}

/* ---------- No history message ---------- */
function renderNoHistoryMessage(key, type) {
  const chartSelector = type === 'valuation'
    ? `[data-val-card="${key}"] .history-chart-container`
    : `[data-ind-card="${key}"] .history-chart-container`;
  const statsSelector = type === 'valuation'
    ? `[data-val-card="${key}"] .history-stats`
    : `[data-ind-card="${key}"] .history-stats`;

  const container = document.querySelector(chartSelector);
  if (container) {
    container.innerHTML = '<div class="no-data-message">Historical data not available</div>';
  }
  const statsEl = document.querySelector(statsSelector);
  if (statsEl) {
    statsEl.innerHTML = '<div class="no-data-message">No historical statistics</div>';
  }
}

/* ---------- Render history chart with period filter ---------- */
function renderIndicatorHistory(key, type = 'indicator', historyData, period = '12M') {
  const indicator = type === 'valuation' ? VALUATIONS[key] : INDICATORS[key];
  if (!indicator || !historyData || !historyData.length) {
    renderNoHistoryMessage(key, type);
    return;
  }

  const selector = type === 'valuation'
    ? `[data-val-card="${key}"] .history-chart`
    : `[data-ind-card="${key}"] .history-chart`;
  const canvas = document.querySelector(selector);
  if (!canvas) {
    console.warn('History canvas missing for', key);
    return;
  }

  const ctx = canvas.getContext('2d');
  if (!ctx || typeof Chart === 'undefined') {
    console.warn('Chart.js not available or context missing');
    return;
  }

  if (indicatorCharts[key]) {
    try { indicatorCharts[key].destroy(); } catch(e) {}
    delete indicatorCharts[key];
  }

  let filtered = historyData;
  const latest = historyData[historyData.length - 1];
  const latestDate = new Date(latest.date);
  if (!isNaN(latestDate)) {
    const cutoff = new Date(latestDate);
    if (period === '12M') {
      cutoff.setMonth(cutoff.getMonth() - 12);
    } else if (period === '5Y') {
      cutoff.setFullYear(cutoff.getFullYear() - 5);
    }
    if (period === '12M' || period === '5Y') {
      filtered = historyData.filter(d => {
        const dDate = new Date(d.date);
        return !isNaN(dDate) && dDate >= cutoff;
      });
    }
  }

  if (!filtered.length) {
    filtered = historyData.slice(-12);
  }

  const labels = filtered.map(item => {
    const d = new Date(item.date);
    if (isNaN(d)) return item.date;
    return d.toLocaleDateString('en-US', { month:'short', year:'2-digit' });
  });
  const data = filtered.map(item => item.value).filter(v => Number.isFinite(v));

  if (!data.length) {
    renderNoHistoryMessage(key, type);
    return;
  }

  let minVal = Math.min(...data);
  let maxVal = Math.max(...data);
  if (!isFinite(minVal) || !isFinite(maxVal)) {
    renderNoHistoryMessage(key, type);
    return;
  }

  if (Math.abs(maxVal - minVal) < 1e-6) {
    const center = minVal;
    minVal = center - 1;
    maxVal = center + 1;
  } else {
    const span = maxVal - minVal;
    const pad = span * 0.15;
    minVal -= pad;
    maxVal += pad;
  }

  const roundTo = (value, step) => Math.round(value / step) * step;
  const step = (maxVal - minVal) > 10 ? 1 : 0.5;
  minVal = roundTo(minVal, step);
  maxVal = roundTo(maxVal, step);

  let lineColor = '#6b9eff';
  if (type === 'indicator') {
    const s = scaleIndicator(key, indicator.current);
    if (s >= 66) lineColor = '#ff6070';
    else if (s >= 33) lineColor = '#ffc247';
    else if (s !== null) lineColor = '#1ec28b';
  } else {
    const s = valuationStress(key, indicator.current);
    if (s >= 66) lineColor = '#ff6070';
    else if (s >= 33) lineColor = '#ffc247';
    else if (s !== null) lineColor = '#1ec28b';
  }

  try {
    indicatorCharts[key] = new Chart(ctx, {
      type:'line',
      data:{
        labels,
        datasets:[{
          label:indicator.label,
          data,
          borderColor:lineColor,
          backgroundColor:lineColor + '20',
          borderWidth:2,
          tension:0.3,
          fill:true,
          pointRadius:2,
          pointBackgroundColor:lineColor,
          pointBorderColor:'#12182b',
          pointBorderWidth:1
        }]
      },
      options:{
        responsive:true,
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{
            backgroundColor:'rgba(18,24,43,0.9)',
            titleColor:'#e8eeff',
            bodyColor:'#e8eeff',
            borderColor:'rgba(255,255,255,0.1)',
            borderWidth:1,
            cornerRadius:4,
            displayColors:false,
            callbacks:{
              label:function(ctx) {
                const value = ctx.parsed.y;
                return indicator.format ? indicator.format(value) : String(value);
              }
            }
          }
        },
        scales:{
          y:{
            min:minVal,
            max:maxVal,
            grid:{ color:'rgba(255,255,255,0.05)' },
            ticks:{ color:'#8b96b0', font:{ size:9 } }
          },
          x:{
            grid:{ color:'rgba(255,255,255,0.03)' },
            ticks:{ color:'#8b96b0', font:{ size:9 } }
          }
        }
      }
    });
  } catch (e) {
    console.error('Chart render error for', key, e);
    renderNoHistoryMessage(key, type);
  }
}

/* ---------- History stats ---------- */
function updateHistoryStats(key, type = 'indicator', historyData) {
  const indicator = type === 'valuation' ? VALUATIONS[key] : INDICATORS[key];
  if (!indicator || !historyData || !historyData.length) return;

  const values = historyData.map(item => item.value).filter(v => Number.isFinite(v));
  if (!values.length) return;

  const current = values[values.length - 1];
  const threeIdx = values.length - 4;
  const sixIdx = values.length - 7;
  const twelveIdx = values.length - 13;

  const getChange = (idx) => {
    if (idx < 0) return null;
    const base = values[idx];
    if (!Number.isFinite(base) || base === 0) return null;
    return ((current - base) / Math.abs(base)) * 100;
  };

  const threeMonthChange = getChange(threeIdx);
  const sixMonthChange = getChange(sixIdx);
  const twelveMonthChange = getChange(twelveIdx);

  const statsSelector = type === 'valuation'
    ? `[data-val-card="${key}"] .history-stats`
    : `[data-ind-card="${key}"] .history-stats`;
  const statsContainer = document.querySelector(statsSelector);
  if (!statsContainer) return;

  const fmt = (val) => indicator.format ? indicator.format(val) : val.toFixed(2);

  const colour = (chg) => {
    if (chg === null) return '#8b96b0';
    return chg >= 0 ? '#1ec28b' : '#ff6070';
  };

  statsContainer.innerHTML = `
    <div class="history-stat">
      <div class="history-stat-label">Current</div>
      <div class="history-stat-value">${fmt(current)}</div>
    </div>
    <div class="history-stat">
      <div class="history-stat-label">3M Change</div>
      <div class="history-stat-value" style="color:${colour(threeMonthChange)}">
        ${threeMonthChange !== null ? threeMonthChange.toFixed(1) + '%' : '--'}
      </div>
    </div>
    <div class="history-stat">
      <div class="history-stat-label">6M Change</div>
      <div class="history-stat-value" style="color:${colour(sixMonthChange)}">
        ${sixMonthChange !== null ? sixMonthChange.toFixed(1) + '%' : '--'}
      </div>
    </div>
    <div class="history-stat">
      <div class="history-stat-label">12M Change</div>
      <div class="history-stat-value" style="color:${colour(twelveMonthChange)}">
        ${twelveMonthChange !== null ? twelveMonthChange.toFixed(1) + '%' : '--'}
      </div>
    </div>
  `;
}

/* ---------- Load + render history orchestrator ---------- */
async function loadAndRenderIndicatorHistory(key, type = 'indicator', period = '12M') {
  const indicator = type === 'valuation' ? VALUATIONS[key] : INDICATORS[key];
  if (!indicator) return;

  if (type === 'valuation' || !indicator.fromFred || !indicator.fredId) {
    renderNoHistoryMessage(key, type);
    return;
  }

  showLoading(`Loading historical data for ${indicator.label}...`);
  try {
    const history = await loadHistoricalData(indicator.fredId, indicator);
    if (history && history.length) {
      renderIndicatorHistory(key, type, history, period);
      updateHistoryStats(key, type, history);
    } else {
      renderNoHistoryMessage(key, type);
    }
  } catch (e) {
    console.error('loadAndRenderIndicatorHistory error for', key, e);
    renderNoHistoryMessage(key, type);
  } finally {
    hideLoading();
  }
}

/* ---------- FRED cache loader (single pipeline) ---------- */
async function loadFromFredCache() {
  try {
    showLoading('Loading FRED data...');
    const res = await fetch('data/fred_cache.json', { cache:'no-store' });
    if (!res.ok) {
      console.error('FRED cache HTTP error', res.status);
      const badge = document.getElementById('cache-badge');
      if (badge) badge.textContent = 'FRED cache: not found';
      return;
    }

    const cache = await res.json();
    const series = cache && cache.series ? cache.series : {};
    const gen = cache && cache.generated_at ? cache.generated_at : 'loaded';
    const badge = document.getElementById('cache-badge');
    if (badge) badge.textContent = 'FRED cache: ' + gen;
    lastUpdateTime = new Date();

    const genDate = new Date(gen);
    if (!isNaN(genDate)) {
      const now = new Date();
      cacheAgeDays = (now - genDate) / (1000 * 60 * 60 * 24);
      if (cacheAgeDays < 0) cacheAgeDays = null;
    }

    Object.keys(INDICATORS).forEach(key => {
      const ind = INDICATORS[key];
      if (!ind.fromFred || !ind.fredId) return;

      const s = series[ind.fredId];
      if (!s || !Array.isArray(s.observations) || !s.observations.length) {
        ind.current = null;
        ind.lastDate = null;
        ind.isStale = false;
        return;
      }

      const processed = processSeriesForIndicator(ind, s);
      if (!Array.isArray(processed) || !processed.length) {
        ind.current = null;
        ind.lastDate = null;
        ind.isStale = false;
        return;
      }

      historicalData[ind.fredId] = processed;
      const lastPoint = processed[processed.length - 1];
      ind.current = Number.isFinite(lastPoint.value) ? lastPoint.value : null;
      ind.lastDate = lastPoint.date || null;

      const lastDt = new Date(lastPoint.date);
      const now = new Date();
      let ageDays = null;
      if (!isNaN(lastDt)) {
        ageDays = (now - lastDt) / (1000 * 60 * 60 * 24);
      }

      let maxFreshDays = 60; // assume monthly-ish
      if (ind.fredId === 'ICSA') maxFreshDays = 21; // weekly claims tighter
      ind.isStale = (ageDays !== null && ageDays > maxFreshDays);
    });

    // Debug logging (non-fatal)
    ['T10Y3M','BAMLH0A0HYM2','UMCSENT','M2SL','NFCI','ICSA','SAHMREALTIME','INDPRO','PERMIT']
      .forEach(id => {
        const history = historicalData[id];
        if (history && history.length) {
          const last = history[history.length - 1];
          console.log(`âœ… ${id} loaded:`, last.value, 'on', last.date);
        } else {
          console.warn(`âš ï¸ ${id} missing or invalid in fred_cache.json`);
        }
      });

  } catch (err) {
    console.error('FRED cache error:', err);
    const badge = document.getElementById('cache-badge');
    if (badge) badge.textContent = 'FRED cache: error';
  } finally {
    hideLoading();
  }
}

/* ---------- Stress mapping ---------- */
function scaleIndicator(key, value) {
  const ind = INDICATORS[key];
  if (!ind || !Number.isFinite(value)) return null;

  const t = ind.threshold;
  const dir = ind.direction;
  const span = (ind.span && ind.span > 0) ? ind.span : Math.max(1, Math.abs(t) * 0.5);
  const buffer = (ind.buffer && ind.buffer > 0) ? ind.buffer : span * 0.5;

  let stress = 0;

  if (dir === 'below') {
    const safeCut = t + buffer;
    if (value >= safeCut) {
      stress = 0;
    } else if (value >= t) {
      const frac = (safeCut - value) / buffer;
      stress = frac * WARN_MAX;
    } else {
      const frac = Math.max(0, Math.min(1, (t - value) / span));
      stress = WARN_MAX + frac * (100 - WARN_MAX);
    }
  } else if (dir === 'above') {
    const safeCut = t - buffer;
    if (value <= safeCut) {
      stress = 0;
    } else if (value <= t) {
      const frac = (value - safeCut) / buffer;
      stress = frac * WARN_MAX;
    } else {
      const frac = Math.max(0, Math.min(1, (value - t) / span));
      stress = WARN_MAX + frac * (100 - WARN_MAX);
    }
  } else {
    return null;
  }

  if (key === 'YIELD_CURVE' && value <= 0) {
    stress = Math.min(100, stress * 1.2);
  }
  if (key === 'SAHM_RULE' && value >= 0.5) {
    stress = Math.min(100, stress * 1.3);
  }

  if (!Number.isFinite(stress)) return null;
  if (stress < 0) stress = 0;
  if (stress > 100) stress = 100;
  return stress;
}

function valuationStress(key, val) {
  if (!Number.isFinite(val)) return null;
  let s = 0;

  if (key === 'BUFFETT') {
    if (val <= 120) s = 0;
    else if (val <= 150) s = (val - 120) / (150 - 120) * 40;
    else if (val <= 200) s = 40 + (val - 150) / (200 - 150) * 60;
    else s = 100;
  } else if (key === 'SHILLER_PE') {
    if (val <= 22) s = 0;
    else if (val <= 30) s = (val - 22) / (30 - 22) * 40;
    else if (val <= 40) s = 40 + (val - 30) / (40 - 30) * 60;
    else s = 100;
  } else {
    return null;
  }

  if (s < 0) s = 0;
  if (s > 100) s = 100;
  return s;
}

function computeComposite() {
  let macroStress = 0, macroTotalWeight = 0;
  Object.entries(INDICATORS).forEach(([k, ind]) => {
    const s = scaleIndicator(k, ind.current);
    if (s !== null && Number.isFinite(s) && ind.weight) {
      macroStress += s * ind.weight;
      macroTotalWeight += ind.weight;
    }
  });

  let valStress = 0, valTotalWeight = 0;
  Object.entries(VALUATIONS).forEach(([k, v]) => {
    const s = valuationStress(k, v.current);
    if (s !== null && Number.isFinite(s) && v.weight) {
      valStress += s * v.weight;
      valTotalWeight += v.weight;
    }
  });

  if (macroTotalWeight === 0 && valTotalWeight === 0) return null;

  const macroComponent = macroTotalWeight > 0 ? (macroStress / macroTotalWeight) : null;
  const valComponent = valTotalWeight > 0 ? (valStress / valTotalWeight) : null;

  let composite = null;
  if (macroComponent !== null && valComponent !== null) {
    composite = macroComponent * MACRO_BLOCK_WEIGHT + valComponent * VALUATION_BLOCK_WEIGHT;
  } else if (macroComponent !== null) {
    composite = macroComponent;
  } else {
    composite = valComponent;
  }

  if (!Number.isFinite(composite)) return null;
  if (composite < 0) composite = 0;
  if (composite > 100) composite = 100;
  return composite;
}

function derivedRecessionRisk(c) {
  if (c == null) return '--';
  if (c < 20) return '<10%';
  if (c < 35) return '10â€“25%';
  if (c < 50) return '25â€“40%';
  if (c < 65) return '40â€“60%';
  if (c < 80) return '60â€“75%';
  return '75â€“90%';
}

function derivedValuationRisk() {
  let sum = 0, w = 0;
  Object.entries(VALUATIONS).forEach(([k, v]) => {
    const s = valuationStress(k, v.current);
    if (s != null && v.weight) {
      sum += s * v.weight;
      w += v.weight;
    }
  });
  if (!w) return '--';
  const sc = Math.round(sum / w);
  if (sc < 33) return 'Low';
  if (sc < 66) return 'Moderate';
  return 'High';
}

function derivedLaborStress() {
  const c = INDICATORS.INITIAL_CLAIMS.current;
  const s = INDICATORS.SAHM_RULE.current;
  if (!Number.isFinite(c) || !Number.isFinite(s)) return '--';
  const cs = Math.max(0, Math.min(100, (c - 250) * 0.5));
  const ss = Math.max(0, Math.min(100, s * 200));
  const avg = (cs + ss) / 2;
  if (avg < 30) return 'Low';
  if (avg < 60) return 'Moderate';
  return 'High';
}

/* ---------- Indicator tiles ---------- */
function buildIndicatorElement(key, ind) {
  const s = scaleIndicator(key, ind.current);
  let cls = 'indicator';
  if (s != null) {
    if (s >= 66) cls += ' danger';
    else if (s >= 33) cls += ' warning';
  }

  const hasVal = Number.isFinite(ind.current);
  const valText = hasVal ? ind.format(ind.current) : '--';

  const thrText = (ind.threshold != null && ind.format)
    ? 'Threshold pivot: ' + ind.format(ind.threshold) +
      (ind.direction === 'below' ? ' (worse below)' : ' (worse above)')
    : '';

  const stressText = (s != null)
    ? 'Stress: ' + Math.round(s) + '/100'
    : 'Stress: --';

  const latestLabel = ind.lastDate ? ('Latest: ' + ind.lastDate) : '';

  let src = ind.fromFred ? 'Auto from FRED' : 'Manual input';
  let srcClass = ind.fromFred ? 'data-source-auto' : 'data-source-manual';

  if (ind.fromFred && !hasVal) {
    src = 'Missing / invalid data';
    srcClass = 'data-source-missing';
  } else if (ind.fromFred && ind.isStale) {
    src = 'Auto from FRED (stale)';
    srcClass = 'data-source-stale';
  }

  let manual = '';
  if (!ind.fromFred && key === 'LEI') {
    manual =
      '<div class="manual-input-row">' +
        '<span>Set latest 6m %Î” for LEI:</span>' +
        '<input class="manual-input" type="number" step="0.1" ' +
        'data-ind-key="'+key+'" value="'+(hasVal ? ind.current : '')+'">' +
      '</div>';
  }

  const historySection = ind.fromFred ? `
    <div class="indicator-history" data-history-key="${key}">
      <div class="history-period-selector">
        <button class="period-btn active" data-period="12M">12M</button>
        <button class="period-btn" data-period="5Y">5Y</button>
        <button class="period-btn" data-period="MAX">MAX</button>
      </div>
      <div class="history-chart-container">
        <canvas class="history-chart"></canvas>
      </div>
      <div class="history-stats"></div>
    </div>
  ` : '';

  const div = document.createElement('div');
  div.className = cls;
  div.setAttribute('data-ind-card', key);
  div.innerHTML =
    '<div class="indicator-header">' +
      '<div class="indicator-name">'+ind.label+'</div>' +
      '<div class="indicator-value" data-ind-value="'+key+'">'+valText+'</div>' +
    '</div>' +
    '<div class="indicator-threshold">'+thrText+'</div>' +
    '<div class="indicator-threshold" data-ind-stress="'+key+'">'+stressText+'</div>' +
    (latestLabel ? '<div class="indicator-threshold">'+latestLabel+'</div>' : '') +
    '<div class="indicator-threshold">'+ind.desc+'</div>' +
    '<div class="data-source-indicator">' +
      '<span class="data-source-dot '+srcClass+'"></span>' +
      '<span class="source-tag">'+src+'</span>' +
    '</div>' +
    manual +
    historySection;

  if (ind.fromFred) {
    div.addEventListener('click', (e) => {
      if (e.target.classList.contains('manual-input') ||
          e.target.classList.contains('period-btn')) {
        return;
      }
      toggleIndicatorExpansion(key, 'indicator');
    });

    const periodButtons = div.querySelectorAll('.period-btn');
    periodButtons.forEach(btn => {
      btn.addEventListener('click', (evt) => {
        evt.stopPropagation();
        const period = btn.getAttribute('data-period') || '12M';
        periodButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        loadHistoricalData(ind.fredId, ind)
          .then(history => {
            if (history && history.length) {
              renderIndicatorHistory(key, 'indicator', history, period);
              updateHistoryStats(key, 'indicator', history);
            } else {
              renderNoHistoryMessage(key, 'indicator');
            }
          })
          .catch(err => {
            console.error('History load error for', key, err);
            renderNoHistoryMessage(key, 'indicator');
          });
      });
    });
  }

  if (ind.tooltip) {
    div.addEventListener('mouseenter', (e) => {
      showTooltip(ind.tooltip, e.pageX + 10, e.pageY + 10);
    });
    div.addEventListener('mousemove', (e) => {
      showTooltip(ind.tooltip, e.pageX + 10, e.pageY + 10);
    });
    div.addEventListener('mouseleave', () => {
      hideTooltip();
    });
  }

  return div;
}

function renderIndicators() {
  const t1 = document.getElementById('tier1-indicators');
  const t2 = document.getElementById('tier2-indicators');
  if (!t1 || !t2) return;

  t1.innerHTML = '';
  t2.innerHTML = '';

  Object.entries(INDICATORS).forEach(([k, ind]) => {
    const el = buildIndicatorElement(k, ind);
    if (!el) return;
    if (ind.tier === 1) t1.appendChild(el);
    else t2.appendChild(el);
  });

  document.querySelectorAll('.manual-input[data-ind-key]').forEach(inp => {
    inp.addEventListener('input', () => {
      const key = inp.getAttribute('data-ind-key');
      const v = parseFloat(inp.value);
      const val = Number.isFinite(v) ? v : null;
      if (!INDICATORS[key]) return;
      INDICATORS[key].current = val;
      const valEl = document.querySelector('[data-ind-value="'+key+'"]');
      if (valEl) valEl.textContent = Number.isFinite(v) ? INDICATORS[key].format(v) : '--';
      persistManualValue(key, val);
      updateDynamic();
    });
  });
}

/* ---------- Valuation tiles ---------- */
function renderValuations() {
  const box = document.getElementById('valuation-indicators');
  if (!box) return;
  box.innerHTML = '';

  Object.entries(VALUATIONS).forEach(([k, v]) => {
    const s = valuationStress(k, v.current);
    let cls = 'indicator';
    if (s != null) {
      if (s >= 66) cls += ' danger';
      else if (s >= 33) cls += ' warning';
    }

    const hasVal = Number.isFinite(v.current);
    const valText = hasVal ? v.format(v.current) : '--';
    const stressText = (s != null)
      ? 'Stress: ' + Math.round(s) + '/100'
      : 'Stress: --';

    let dangerLabel = '';
    if (k === 'BUFFETT') dangerLabel = 'Danger band: > 200%';
    else if (k === 'SHILLER_PE') dangerLabel = 'Danger band: > 30';
    else dangerLabel = 'Danger band: ' + v.danger;

    const div = document.createElement('div');
    div.className = cls;
    div.setAttribute('data-val-card', k);
    div.innerHTML =
      '<div class="indicator-header">' +
        '<div class="indicator-name">'+v.label+'</div>' +
        '<div class="indicator-value" data-val-value="'+k+'">'+valText+'</div>' +
      '</div>' +
      '<div class="indicator-threshold">'+dangerLabel+'</div>' +
      '<div class="indicator-threshold" data-val-stress="'+k+'">'+stressText+'</div>' +
      '<div class="indicator-threshold">'+v.desc+'</div>' +
      '<div class="data-source-indicator">' +
        '<span class="data-source-dot data-source-manual"></span>' +
        '<span class="source-tag">Manual input</span>' +
      '</div>' +
      '<div class="manual-input-row">' +
        '<span>Set current reading:</span>' +
        '<input class="manual-input" type="number" step="0.1" ' +
        'data-val-key="'+k+'" value="'+(hasVal ? v.current : '')+'">' +
      '</div>';

    if (v.tooltip) {
      div.addEventListener('mouseenter', (e) => {
        showTooltip(v.tooltip, e.pageX + 10, e.pageY + 10);
      });
      div.addEventListener('mousemove', (e) => {
        showTooltip(v.tooltip, e.pageX + 10, e.pageY + 10);
      });
      div.addEventListener('mouseleave', () => {
        hideTooltip();
      });
    }

    box.appendChild(div);
  });

  document.querySelectorAll('.manual-input[data-val-key]').forEach(inp => {
    inp.addEventListener('input', () => {
      const key = inp.getAttribute('data-val-key');
      const v = parseFloat(inp.value);
      const val = Number.isFinite(v) ? v : null;
      if (!VALUATIONS[key]) return;
      VALUATIONS[key].current = val;

      const valEl = document.querySelector('[data-val-value="'+key+'"]');
      if (valEl) valEl.textContent = Number.isFinite(v) ? VALUATIONS[key].format(v) : '--';

      persistManualValue(key, val);
      updateDynamic();
    });
  });
}

/* ---------- LocalStorage persistence ---------- */
function loadFromLocalStorage() {
  try {
    const raw = localStorage.getItem('crashRadarManual');
    if (!raw) return;
    const stored = JSON.parse(raw);
    if (!stored || typeof stored !== 'object') return;

    Object.entries(stored).forEach(([key, val]) => {
      const num = parseFloat(val);
      if (!Number.isFinite(num)) return;
      if (INDICATORS[key] && !INDICATORS[key].fromFred) {
        INDICATORS[key].current = num;
      } else if (VALUATIONS[key]) {
        VALUATIONS[key].current = num;
      }
    });
  } catch (e) {
    console.warn('Failed to load manual inputs from localStorage', e);
  }
}

function persistManualValue(key, value) {
  try {
    const raw = localStorage.getItem('crashRadarManual');
    const stored = raw ? JSON.parse(raw) : {};
    if (!stored || typeof stored !== 'object') return;
    if (value === null || value === undefined || !Number.isFinite(value)) {
      delete stored[key];
    } else {
      stored[key] = value;
    }
    localStorage.setItem('crashRadarManual', JSON.stringify(stored));
  } catch (e) {
    console.warn('Failed to persist manual value', key, e);
  }
}

/* ---------- Valuation summary box ---------- */
function syncValuationCurrentBox() {
  const b = VALUATIONS.BUFFETT.current;
  const c = VALUATIONS.SHILLER_PE.current;
  const bEl = document.getElementById('current-buffett-label');
  const cEl = document.getElementById('current-cape-label');

  if (bEl) {
    bEl.textContent = Number.isFinite(b)
      ? ('Buffett: ' + b.toFixed(1) + '%')
      : 'Buffett: --';
  }
  if (cEl) {
    cEl.textContent = Number.isFinite(c)
      ? ('CAPE: ' + c.toFixed(1))
      : 'CAPE: --';
  }
}

/* ---------- Gauge & status ---------- */
function renderGaugeAndStatus() {
  compositeScore = computeComposite();

  const scoreEl = document.getElementById('composite-score');
  const needle = document.getElementById('needle');
  const fill = document.getElementById('risk-fill');
  const regimeEl = document.getElementById('regime-label');
  const alert = document.getElementById('alert-banner');
  const inputsBadge = document.getElementById('inputs-badge');
  const qualityDisplay = document.getElementById('quality-display');

  const total = Object.keys(INDICATORS).length + Object.keys(VALUATIONS).length;
  const used =
    Object.keys(INDICATORS).filter(k => Number.isFinite(INDICATORS[k].current)).length +
    Object.keys(VALUATIONS).filter(k => Number.isFinite(VALUATIONS[k].current)).length;

  const coverage = total ? (used / total) : 0;
  if (inputsBadge) inputsBadge.textContent = 'Inputs: ' + used + '/' + total + ' populated';
  if (qualityDisplay) qualityDisplay.textContent = total ? Math.round(coverage * 100) + '%' : '--';

  if (!scoreEl || !needle || !fill || !regimeEl || !alert) return;

  if (compositeScore == null) {
    scoreEl.textContent = '--';
    fill.style.width = '0%';
    needle.style.transform = 'translateX(-50%) rotate(0deg)';
    regimeEl.textContent = 'COMPOSITE STRESS â€” insufficient data';
    const rr = document.getElementById('recession-risk-display');
    const vr = document.getElementById('valuation-risk-display');
    const lr = document.getElementById('labor-risk-display');
    if (rr) rr.textContent = '--';
    if (vr) vr.textContent = '--';
    if (lr) lr.textContent = '--';

    let msg = 'No composite yet. Check FRED cache and manual LEI / valuation inputs.';
    if (cacheAgeDays != null && cacheAgeDays > 7) {
      msg = 'Data warning: FRED cache is ' + cacheAgeDays.toFixed(1) +
            ' days old. Update fred_cache.json. ' + msg;
    }
    alert.textContent = msg;
    return;
  }

  const v = Math.round(compositeScore);
  scoreEl.textContent = v;
  fill.style.width = v + '%';
  const angle = (v / 100) * 360;
  needle.style.transform = 'translateX(-50%) rotate(' + angle + 'deg)';

  let regime;
  if (v <= 30) regime = 'Low stress regime';
  else if (v <= 50) regime = 'Elevated â€” monitor';
  else if (v <= 70) regime = 'High â€” defensive bias';
  else regime = 'Critical regime';

  regimeEl.textContent = 'COMPOSITE STRESS â€” ' + regime;
  const rr = document.getElementById('recession-risk-display');
  const vr = document.getElementById('valuation-risk-display');
  const lr = document.getElementById('labor-risk-display');
  if (rr) rr.textContent = derivedRecessionRisk(v);
  if (vr) vr.textContent = derivedValuationRisk();
  if (lr) lr.textContent = derivedLaborStress();

  let prefix = '';
  if (cacheAgeDays != null && cacheAgeDays > 7) {
    prefix += 'Data warning: FRED cache is ' + cacheAgeDays.toFixed(1) + ' days old. Update fred_cache.json. ';
  }
  if (coverage < 0.8) {
    prefix += 'Coverage below 80%. Treat composite as tentative. ';
  }

  if (v >= 70) {
    alert.innerHTML = prefix + '<strong>Critical:</strong> Composite = ' + v +
      '. Macro + valuations in historical danger cluster.';
  } else if (v >= 50) {
    alert.innerHTML = prefix + '<strong>Warning:</strong> Composite = ' + v +
      '. Elevated risk â€” inspect indicator tiles.';
  } else {
    alert.textContent = prefix + 'Composite = ' + v +
      '. No classic crash cluster on this configuration; still consider exogenous shocks.';
  }
}

/* ---------- Charts ---------- */
function renderMarketTrendChart() {
  const canvas = document.getElementById('market-trend');
  if (!canvas || typeof Chart === 'undefined') return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  if (charts.trend) {
    try { charts.trend.destroy(); } catch (e) {}
    charts.trend = null;
  }

  const base = compositeScore != null ? compositeScore : 40;
  const labels = ['T-10','T-8','T-6','T-4','T-2','Now'];

  const compData = [0.7,0.8,0.9,0.95,0.98,1].map(f => {
    let x = base * f;
    if (x < 0) x = 0;
    if (x > 100) x = 100;
    return Math.round(x);
  });

  let vSum = 0, vW = 0;
  Object.entries(VALUATIONS).forEach(([k, v]) => {
    const s = valuationStress(k, v.current);
    if (s != null && v.weight) {
      vSum += s * v.weight;
      vW += v.weight;
    }
  });
  const valBase = vW ? (vSum / vW) : 30;
  const valData = [0.75,0.85,0.92,0.96,0.99,1].map(f => {
    let x = valBase * f;
    if (x < 0) x = 0;
    if (x > 100) x = 100;
    return Math.round(x);
  });

  try {
    charts.trend = new Chart(ctx, {
      type:'line',
      data:{
        labels,
        datasets:[
          {
            label:'Composite Stress',
            data:compData,
            borderColor:'#6b9eff',
            backgroundColor:'rgba(107,158,255,0.14)',
            tension:0.32,
            fill:true,
            pointRadius:2
          },
          {
            label:'Valuation Stress',
            data:valData,
            borderColor:'#ff6070',
            backgroundColor:'rgba(255,96,112,0.12)',
            tension:0.32,
            fill:true,
            pointRadius:2
          }
        ]
      },
      options:{
        responsive:true,
        plugins:{
          legend:{ labels:{ color:'#e8eeff', font:{ size:9 } } },
          title:{
            display:true,
            text:'Stress & Valuation Trajectory (illustrative)',
            color:'#e8eeff',
            font:{ size:11 }
          }
        },
        scales:{
          y:{
            min:0,
            max:100,
            ticks:{ color:'#8b96b0', font:{ size:8 } },
            grid:{ color:'rgba(255,255,255,0.08)' }
          },
          x:{
            ticks:{ color:'#8b96b0', font:{ size:8 } },
            grid:{ color:'rgba(255,255,255,0.06)' }
          }
        }
      }
    });
  } catch (e) {
    console.error('Market trend chart error', e);
  }
}

function renderRiskRadarChart() {
  const canvas = document.getElementById('risk-radar');
  if (!canvas || typeof Chart === 'undefined') return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  if (charts.radar) {
    try { charts.radar.destroy(); } catch (e) {}
    charts.radar = null;
  }

  const labels = [];
  const data = [];

  Object.entries(INDICATORS).forEach(([k, ind]) => {
    const s = scaleIndicator(k, ind.current);
    if (s != null) {
      labels.push(ind.label);
      data.push(Math.round(s));
    }
  });

  let vSum = 0, vW = 0;
  Object.entries(VALUATIONS).forEach(([k, v]) => {
    const s = valuationStress(k, v.current);
    if (s != null && v.weight) {
      vSum += s * v.weight;
      vW += v.weight;
    }
  });
  if (vW) {
    labels.push('Valuations (Buffett + CAPE)');
    data.push(Math.round(vSum / vW));
  }

  if (!labels.length) return;

  try {
    charts.radar = new Chart(ctx, {
      type:'radar',
      data:{
        labels,
        datasets:[{
          label:'Normalized Stress (0â€“100)',
          data,
          borderColor:'#6b9eff',
          backgroundColor:'rgba(107,158,255,0.18)',
          pointRadius:2
        }]
      },
      options:{
        responsive:true,
        plugins:{ legend:{ display:false } },
        scales:{
          r:{
            angleLines:{ color:'rgba(255,255,255,0.05)' },
            grid:{ color:'rgba(255,255,255,0.09)' },
            suggestedMin:0,
            suggestedMax:100,
            ticks:{ display:false },
            pointLabels:{ color:'#8b96b0', font:{ size:7 } }
          }
        }
      }
    });
  } catch (e) {
    console.error('Radar chart error', e);
  }
}

/* ---------- Insight text ---------- */
function updateInsight() {
  const el = document.getElementById('insight-text');
  if (!el) return;

  const c = compositeScore;
  const vRisk = derivedValuationRisk();

  if (c == null) {
    el.textContent = 'No composite yet. Ensure fred_cache.json is fresh and LEI / Buffett / CAPE are populated.';
  } else if (c >= 70 && vRisk === 'High') {
    el.textContent = 'Macro + valuations both extreme: configuration consistent with major drawdown regimes.';
  } else if (c >= 50 && vRisk !== 'Low') {
    el.textContent = 'Elevated macro stress with stretched valuations: risk-reward skewed left.';
  } else if (c < 40 && vRisk === 'High') {
    el.textContent = 'Macro relatively okay but valuations rich: vulnerable to shocks or policy error.';
  } else if (c < 40 && vRisk === 'Low') {
    el.textContent = 'Macro and valuations both moderate vs history: no classic crash cluster here.';
  } else {
    el.textContent = 'Mixed configuration. Use radar and tiles to see what drives the score.';
  }
}

/* ---------- Export / share ---------- */
function exportToCSV() {
  try {
    let csvContent = "Indicator,Current Value,Stress Score,Threshold\n";
    Object.entries(INDICATORS).forEach(([key, ind]) => {
      const stress = scaleIndicator(key, ind.current);
      const stressText = stress !== null ? stress.toFixed(1) : 'N/A';
      const valueText = ind.current !== null ? ind.current : 'N/A';
      const thresholdText = ind.threshold !== null ? ind.threshold : 'N/A';
      csvContent += `"${ind.label}","${valueText}","${stressText}","${thresholdText}"\n`;
    });
    Object.entries(VALUATIONS).forEach(([key, val]) => {
      const stress = valuationStress(key, val.current);
      const stressText = stress !== null ? stress.toFixed(1) : 'N/A';
      const valueText = val.current !== null ? val.current : 'N/A';
      const thresholdText = val.danger !== null ? val.danger : 'N/A';
      csvContent += `"${val.label}","${valueText}","${stressText}","${thresholdText}"\n`;
    });
    csvContent += `"Composite Score","${compositeScore !== null ? compositeScore.toFixed(1) : 'N/A'}","",""\n`;

    const blob = new Blob([csvContent], { type:'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `economic_crash_radar_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (e) {
    console.error('CSV export error', e);
    alert('CSV export failed. See console for details.');
  }
}

function exportToPDF() {
  showLoading('Generating PDF report...');
  setTimeout(() => {
    alert('PDF export placeholder. Implement with jsPDF or similar in production.');
    hideLoading();
  }, 700);
}

function saveSnapshot() {
  try {
    const snapshot = {
      timestamp:new Date().toISOString(),
      compositeScore:compositeScore,
      indicators:{},
      valuations:{}
    };
    Object.entries(INDICATORS).forEach(([key, ind]) => {
      snapshot.indicators[key] = ind.current;
    });
    Object.entries(VALUATIONS).forEach(([key, val]) => {
      snapshot.valuations[key] = val.current;
    });

    const raw = localStorage.getItem('crashRadarSnapshots');
    const snapshots = raw ? JSON.parse(raw) : [];
    if (!Array.isArray(snapshots)) {
      console.warn('Snapshots storage invalid, resetting');
      localStorage.setItem('crashRadarSnapshots', JSON.stringify([snapshot]));
    } else {
      snapshots.push(snapshot);
      localStorage.setItem('crashRadarSnapshots', JSON.stringify(snapshots));
    }
    alert('Snapshot saved. (Comparison UI still to be implemented.)');
  } catch (e) {
    console.error('Snapshot error', e);
    alert('Snapshot save failed. See console for details.');
  }
}

function shareLink() {
  try {
    const params = new URLSearchParams();
    Object.entries(INDICATORS).forEach(([key, ind]) => {
      if (ind.current !== null && Number.isFinite(ind.current)) {
        params.set(`i_${key}`, ind.current.toString());
      }
    });
    Object.entries(VALUATIONS).forEach(([key, val]) => {
      if (val.current !== null && Number.isFinite(val.current)) {
        params.set(`v_${key}`, val.current.toString());
      }
    });

    const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;

    if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(shareUrl)
        .then(() => alert('Shareable link copied to clipboard!'))
        .catch(() => {
          fallbackCopyToClipboard(shareUrl);
        });
    } else {
      fallbackCopyToClipboard(shareUrl);
    }
  } catch (e) {
    console.error('Share link error', e);
    alert('Failed to build share link. See console for details.');
  }
}

function fallbackCopyToClipboard(text) {
  try {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.opacity = '0';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    alert('Shareable link copied to clipboard!');
  } catch (e) {
    console.error('Clipboard fallback error', e);
    alert('Copy to clipboard failed. Copy the URL from the address bar.');
  }
}

/* ---------- Reset & help ---------- */
function resetInputs() {
  if (!confirm('Are you sure you want to reset all inputs? This will clear all manual entries.')) return;

  Object.entries(INDICATORS).forEach(([key, ind]) => {
    if (!ind.fromFred) ind.current = null;
  });
  Object.entries(VALUATIONS).forEach(([key, val]) => {
    val.current = null;
  });

  try {
    localStorage.removeItem('crashRadarManual');
  } catch (e) {
    console.warn('Failed to clear manual inputs from localStorage', e);
  }

  updateAll();
}

function showHelp() {
  const helpContent = `
Economic Crash Radar Pro v7

This tool monitors 12 economic indicators to assess recession risk.

Macro Indicators (10)
- Tier 1 (Leading): LEI, Yield Curve, Credit Spread, Financial Stress, Consumer Sentiment, M2 Growth
- Tier 2 (Confirming): Industrial Production, Building Permits, Initial Claims, Sahm Rule

Valuation Indicators (2)
- Buffett Indicator: Stock Market Cap / GDP
- Shiller CAPE: Cyclically Adjusted P/E Ratio

How to Use
1. Ensure FRED data is loaded (auto for most indicators).
2. Manually input LEI 6m %Î”, Buffett Indicator, and CAPE values.
3. Watch the composite score and individual indicator stress.
4. Click any FRED-based indicator to see its history; use 12M / 5Y / MAX.
5. Use Export / Snapshot / Share to document and compare regimes.

Interpreting Composite
- 0â€“30: Low stress regime
- 30â€“50: Elevated â€“ monitor closely
- 50â€“70: High â€“ defensive bias
- 70â€“100: Critical â€“ historical danger zone
  `;
  alert(helpContent);
}

/* ---------- URL param loader ---------- */
function loadFromURL() {
  try {
    const urlParams = new URLSearchParams(window.location.search);
    Object.entries(INDICATORS).forEach(([key, ind]) => {
      const paramValue = urlParams.get(`i_${key}`);
      if (paramValue !== null) {
        const value = parseFloat(paramValue);
        if (!isNaN(value)) ind.current = value;
      }
    });
    Object.entries(VALUATIONS).forEach(([key, val]) => {
      const paramValue = urlParams.get(`v_${key}`);
      if (paramValue !== null) {
        const value = parseFloat(paramValue);
        if (!isNaN(value)) val.current = value;
      }
    });
  } catch (e) {
    console.warn('Failed to parse URL params', e);
  }
}

/* ---------- Orchestration ---------- */
function updateDynamic() {
  renderGaugeAndStatus();
  renderMarketTrendChart();
  renderRiskRadarChart();
  syncValuationCurrentBox();
  updateInsight();
}

function updateAll() {
  renderIndicators();
  renderValuations();
  updateDynamic();
}

document.addEventListener('DOMContentLoaded', () => {
  // 1) LocalStorage manual values
  loadFromLocalStorage();

  // 2) URL query overrides
  loadFromURL();

  // 3) Load FRED + render
  loadFromFredCache()
    .then(updateAll)
    .catch(err => {
      console.error('Init error:', err);
      updateAll();
    });

  const refreshBtn = document.getElementById('refresh-data');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', () => {
      loadFromFredCache()
        .then(updateAll)
        .catch(err => {
          console.error('Refresh error:', err);
          updateAll();
        });
    });
  }

  const resetBtn = document.getElementById('reset-inputs');
  if (resetBtn) resetBtn.addEventListener('click', resetInputs);

  const helpBtn = document.getElementById('show-help');
  if (helpBtn) helpBtn.addEventListener('click', showHelp);

  const csvBtn = document.getElementById('export-csv');
  if (csvBtn) csvBtn.addEventListener('click', exportToCSV);

  const pdfBtn = document.getElementById('export-pdf');
  if (pdfBtn) pdfBtn.addEventListener('click', exportToPDF);

  const snapBtn = document.getElementById('export-snapshot');
  if (snapBtn) snapBtn.addEventListener('click', saveSnapshot);

  const shareBtn = document.getElementById('share-link');
  if (shareBtn) shareBtn.addEventListener('click', shareLink);
});
</script>
</body>
</html>
