<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Economic Crash Radar Pro</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg:#0a0e1a;
      --panel:#12182b;
      --panel-soft:#0c1020;
      --text:#e8eeff;
      --muted:#8b96b0;
      --accent:#6b9eff;
      --accent-bright:#8fb4ff;
      --green:#1ec28b;
      --amber:#ffc247;
      --red:#ff6070;
      --radius-lg:16px;
      --radius-md:10px;
      --shadow-soft:0 8px 24px rgba(0,0,0,0.45);
      --font-main:-apple-system,BlinkMacSystemFont,"Segoe UI",system-ui,sans-serif;
      --fs-xs:9px;
      --fs-sm:10px;
      --fs-md:11px;
      --fs-lg:13px;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background:var(--bg);
      color:var(--text);
      font:15px/1.6 var(--font-main);
      -webkit-font-smoothing:antialiased;
      padding:18px 12px 40px;
    }
    .container{max-width:1440px;margin:0 auto;}
    .header{text-align:center;margin-bottom:18px;}
    h1{
      font-size:clamp(30px,6vw,46px);
      font-weight:800;
      margin-bottom:6px;
      background:linear-gradient(135deg,var(--text),var(--accent-bright));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
    }
    .subtitle{
      color:var(--muted);
      font-size:0.95rem;
    }
    .meta-badges{
      display:flex;flex-wrap:wrap;justify-content:center;
      gap:6px;margin-top:8px;font-size:var(--fs-xs);color:var(--muted);
    }
    .badge{
      padding:4px 8px;border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.02);
    }
    .alert-banner{
      margin:16px auto 18px;padding:10px 12px;max-width:900px;
      border-radius:10px;
      background:linear-gradient(135deg,rgba(107,158,255,0.08),rgba(139,187,255,0.02));
      border:1px solid rgba(107,158,255,0.25);
      font-size:var(--fs-sm);color:var(--text);
    }
    .dashboard{
      display:grid;
      grid-template-columns:280px 1fr;
      gap:16px;
      align-items:flex-start;
    }
    @media(max-width:900px){
      body{padding:14px 8px 26px;}
      .dashboard{grid-template-columns:1fr;}
    }
    .sidebar{
      background:var(--panel);
      border-radius:var(--radius-lg);
      padding:16px 14px 14px;
      box-shadow:var(--shadow-soft);
    }
    .main-content{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:14px;
    }
    @media(max-width:900px){
      .main-content{grid-template-columns:1fr;}
      .sidebar{order:-1;}
    }
    .card{
      background:var(--panel);
      border-radius:var(--radius-lg);
      padding:14px 12px 12px;
      box-shadow:var(--shadow-soft);
    }
    .card-title{
      font-size:var(--fs-lg);
      font-weight:700;
      color:var(--accent-bright);
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:8px;
    }
    .card-title .icon{font-size:1.1rem;}
    .gauge-container{text-align:center;margin-bottom:8px;}
    .gauge{position:relative;width:190px;height:190px;margin:0 auto;}
    .gauge-background{
      position:absolute;inset:0;border-radius:50%;
      background:conic-gradient(
        var(--green) 0deg 108deg,
        var(--amber) 108deg 216deg,
        var(--red) 216deg 360deg
      );
      opacity:0.28;
    }
    .gauge-center{
      position:absolute;top:10%;left:10%;width:80%;height:80%;
      border-radius:50%;background:var(--panel-soft);
      display:flex;flex-direction:column;align-items:center;justify-content:center;
    }
    .gauge-score{font-size:2.4rem;font-weight:800;}
    .gauge-label{
      font-size:var(--fs-xs);color:var(--muted);
      text-transform:uppercase;letter-spacing:0.08em;margin-top:2px;
    }
    .gauge-needle{
      position:absolute;bottom:50%;left:50%;
      width:3px;height:46%;background:var(--accent);
      transform-origin:bottom center;
      transform:translateX(-50%) rotate(0deg);
      border-radius:4px 4px 0 0;
      transition:transform 0.9s ease;
    }
    .risk-meter{margin-top:6px;}
    .risk-bar{
      height:6px;border-radius:4px;
      background:rgba(255,255,255,0.1);overflow:hidden;
    }
    .risk-fill{
      height:100%;width:0%;
      background:linear-gradient(90deg,var(--green),var(--amber),var(--red));
      transition:width 0.8s ease;
    }
    .risk-labels{
      display:flex;justify-content:space-between;
      margin-top:4px;font-size:var(--fs-xs);color:var(--muted);
    }
    .status-grid{
      display:grid;grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px;margin-top:10px;
    }
    .status-item{
      padding:7px 6px;background:rgba(255,255,255,0.02);
      border-radius:8px;font-size:var(--fs-xs);
    }
    .status-label{color:var(--muted);font-size:var(--fs-xs);}
    .status-value{font-weight:700;font-size:0.95rem;margin:1px 0 0;}
    .indicator-grid{
      display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));
      gap:7px;margin-top:4px;
    }
    .indicator{
      padding:7px 7px 6px;
      background:rgba(255,255,255,0.03);
      border-radius:8px;
      border-left:3px solid var(--green);
      font-size:var(--fs-xs);
    }
    .indicator.warning{border-left-color:var(--amber);}
    .indicator.danger{border-left-color:var(--red);}
    .indicator.core::before{
      content:'Core';
      display:inline-block;
      margin-right:4px;
      padding:1px 4px;
      font-size:7px;
      border-radius:6px;
      border:1px solid rgba(107,158,255,0.5);
      color:var(--accent-bright);
    }
    .indicator-header{
      display:flex;justify-content:space-between;
      gap:4px;align-items:baseline;margin-bottom:2px;
    }
    .indicator-name{font-weight:600;font-size:0.78rem;}
    .indicator-value{font-weight:700;font-size:0.9rem;}
    .indicator-threshold{
      color:var(--muted);font-size:var(--fs-xs);margin-top:1px;
    }
    .source-tag{
      display:inline-block;margin-top:3px;padding:2px 5px;
      border-radius:6px;border:1px solid rgba(255,255,255,0.14);
      font-size:7px;color:var(--muted);
    }
    .manual-input-row{
      display:flex;align-items:center;gap:3px;
      margin-top:3px;font-size:7px;
    }
    .manual-input{
      width:72px;padding:2px 4px;border-radius:4px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.5);
      color:var(--text);font-size:var(--fs-xs);outline:none;
    }
    .manual-input:focus{
      border-color:var(--accent);
      box-shadow:0 0 4px var(--accent);
    }
    .valuation-comparison{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(150px,1fr));
      gap:6px;margin-top:8px;font-size:var(--fs-xs);
    }
    .valuation-item{
      padding:6px;background:rgba(255,255,255,0.02);
      border-radius:8px;text-align:center;
    }
    .valuation-item.current{
      border:1px solid var(--red);
      background:rgba(255,96,112,0.05);
    }
    .valuation-title{font-weight:600;margin-bottom:2px;}
    .valuation-metric{margin:1px 0;}
    .valuation-outcome{margin-top:2px;color:var(--muted);}
    .insight-card{
      margin-top:6px;padding:6px 7px;border-radius:8px;
      background:linear-gradient(135deg,rgba(107,158,255,0.10),rgba(10,14,26,1));
      border:1px solid rgba(107,158,255,0.25);
      font-size:var(--fs-xs);
    }
    .chart-container{margin-top:4px;}
    .history-grid{
      margin-top:6px;
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
      gap:5px;font-size:var(--fs-xs);
    }
    .history-item{
      padding:5px;border-radius:8px;
      background:rgba(255,255,255,0.02);
    }
    .history-title{
      font-weight:600;margin-bottom:1px;font-size:var(--fs-xs);
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>âš¡ Economic Crash Radar Pro</h1>
    <div class="subtitle">
      Composite Economic Fragility Index (CEFI) + macro & valuation tiles. Engineered for transparency.
    </div>
    <div class="meta-badges">
      <div class="badge" id="cache-badge">FRED cache: not loaded</div>
      <div class="badge">Core: YC, HY, VIX, Claims, optional Drawdown</div>
      <div class="badge">Valuations: Buffett &amp; CAPE (separate stress)</div>
      <div class="badge" id="inputs-badge">Inputs: 0 populated</div>
    </div>
  </div>

  <div class="alert-banner" id="alert-banner">
    Composite headline = 70% macro CEFI + 30% valuation stress when valuations are set; otherwise pure macro CEFI.
  </div>

  <div class="dashboard">
    <!-- SIDEBAR: GAUGE + STATUS -->
    <aside class="sidebar">
      <div class="gauge-container">
        <div class="gauge">
          <div class="gauge-background"></div>
          <div class="gauge-center">
            <div class="gauge-score" id="composite-score">--</div>
            <div class="gauge-label" id="regime-label">COMPOSITE STRESS</div>
          </div>
          <div class="gauge-needle" id="needle"></div>
        </div>
        <div class="risk-meter">
          <div class="risk-bar">
            <div class="risk-fill" id="risk-fill"></div>
          </div>
          <div class="risk-labels">
            <span>Low (0â€“24)</span>
            <span>Caution (25â€“49)</span>
            <span>Elevated (50â€“69)</span>
            <span>High/Cr. (70â€“100)</span>
          </div>
        </div>
      </div>

      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">Macro CEFI</div>
          <div class="status-value" id="macro-cefi-display">--</div>
          <div class="indicator-threshold">0â€“100 based on core drivers.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Valuation Stress</div>
          <div class="status-value" id="valuation-risk-display">--</div>
          <div class="indicator-threshold">Separate 0â€“100 Buffett+CAPE.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Recession Prob (12â€“18m)</div>
          <div class="status-value" id="recession-risk-display">--</div>
          <div class="indicator-threshold">Mapped from composite headline.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Data Coverage</div>
          <div class="status-value" id="quality-display">--</div>
          <div class="indicator-threshold">Drivers available / expected.</div>
        </div>
      </div>
    </aside>

    <!-- MAIN CONTENT -->
    <section class="main-content">
      <!-- Tier 1 -->
      <div class="card">
        <div class="card-title"><span class="icon">ðŸ“Š</span>Tier 1 Leading & Core Drivers</div>
        <div class="indicator-grid" id="tier1-indicators"></div>
      </div>

      <!-- Tier 2 -->
      <div class="card">
        <div class="card-title"><span class="icon">ðŸ“ˆ</span>Tier 2 Confirming & Context</div>
        <div class="indicator-grid" id="tier2-indicators"></div>
      </div>

      <!-- Valuations -->
      <div class="card">
        <div class="card-title"><span class="icon">ðŸ’°</span>Valuation Indicators</div>
        <div class="indicator-grid" id="valuation-indicators"></div>
        <div class="valuation-comparison">
          <div class="valuation-item">
            <div class="valuation-title">2000 Dot-com</div>
            <div class="valuation-metric">CAPE â‰ˆ 44</div>
            <div class="valuation-metric">Buffett â‰ˆ 140â€“160%</div>
            <div class="valuation-outcome">Major drawdown.</div>
          </div>
          <div class="valuation-item">
            <div class="valuation-title">2007 Pre-GFC</div>
            <div class="valuation-metric">CAPE â‰ˆ 27</div>
            <div class="valuation-metric">Buffett â‰ˆ 105%</div>
            <div class="valuation-outcome">Crisis followed.</div>
          </div>
          <div class="valuation-item">
            <div class="valuation-title">2021 Peak</div>
            <div class="valuation-metric">CAPE â‰ˆ 38</div>
            <div class="valuation-metric">Buffett â‰ˆ 195%</div>
            <div class="valuation-outcome">2022 correction.</div>
          </div>
          <div class="valuation-item current">
            <div class="valuation-title">Current (your inputs)</div>
            <div class="valuation-metric" id="current-buffett-label">Buffett: --</div>
            <div class="valuation-metric" id="current-cape-label">CAPE: --</div>
            <div class="valuation-outcome">Manual; feeds Valuation Stress only.</div>
          </div>
        </div>
      </div>

      <!-- History / Radar -->
      <div class="card">
        <div class="card-title"><span class="icon">ðŸ•’</span>History, Radar & Prior Recessions</div>
        <div class="chart-container">
          <canvas id="cefi-trend" height="130"></canvas>
        </div>
        <div class="chart-container">
          <canvas id="risk-radar" height="140"></canvas>
        </div>
        <div class="insight-card">
          <strong>Insight:</strong>
          <span id="insight-text">
            Load completes once core drivers + valuations are in. Compare today vs prior clusters.
          </span>
        </div>
        <div class="history-grid">
          <div class="history-item">
            <div class="history-title">1973â€“75 / early 80s</div>
            <div>Curve inversion + tight policy + weak leads clustered.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2000â€“02</div>
            <div>Extreme valuations + tightening; macro rolled with a lag.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2007â€“09</div>
            <div>Housing + credit + inversion aligned.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2020 Shock</div>
            <div>Exogenous collapse; classic leads gave limited warning.</div>
          </div>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
'use strict';

// ---- CONFIG ----

// Core CEFI drivers (4â€“5 indicators, non-redundant)
const CEFI_DRIVERS = {
  YC_10Y3M: { fredId: 'T10Y3M', weight: 0.30, direction: 'lowBad' },
  HY_OAS:   { fredId: 'BAMLH0A0HYM2', weight: 0.25, direction: 'highBad' },
  VIX:      { fredId: 'VIXCLS', weight: 0.15, direction: 'highBad' },
  CLAIMS:   { fredId: 'ICSA', weight: 0.15, direction: 'highBad', transform: 'claims4w' },
  DD_12M:   { fredId: 'SP500', weight: 0.15, direction: 'highBad', transform: 'dd12m' } // optional
};

// Max YC+HY dominance in composite points (soft cap)
const MAX_CORE_POINTS = 40;

// Composite headline weighting macro vs valuations
const VALUATION_HEADLINE_WEIGHT = 0.30;

// Indicator tiles (some are core, some contextual)
const INDICATORS = {
  LEI: {
    tier:1, core:false,
    label:'Conference Board LEI 6m %Î”',
    desc:'Manual quarterly input. Negative beyond -4.1% historically warns.',
    manual:true,
    current:null,
    fmt:v=>v.toFixed(1)+'%',
    threshold:-4.1,
    direction:'below'
  },
  YC_10Y3M: {
    tier:1, core:true,
    label:'Yield Curve (10yâ€“3m)',
    desc:'T10Y3M. Core CEFI driver; inversion risk.',
    fredId:'T10Y3M',
    current:null,
    fmt:v=>v.toFixed(2)+'%',
    noteCore:true
  },
  HY_OAS: {
    tier:1, core:true,
    label:'HY Credit Spread',
    desc:'BAMLH0A0HYM2. Core CEFI driver; funding stress.',
    fredId:'BAMLH0A0HYM2',
    current:null,
    fmt:v=>v.toFixed(2)+'%'
  },
  VIX: {
    tier:1, core:true,
    label:'VIX Volatility',
    desc:'VIXCLS. Core CEFI driver; market risk.',
    fredId:'VIXCLS',
    current:null,
    fmt:v=>v.toFixed(1)
  },
  UMICH: {
    tier:1, core:false,
    label:'UMich Sentiment',
    desc:'UMCSENT. Demand & risk appetite.',
    fredId:'UMCSENT',
    current:null,
    fmt:v=>v.toFixed(1)
  },
  CLAIMS: {
    tier:2, core:true,
    label:'Initial Claims 4wk MA',
    desc:'ICSA. Core CEFI driver (4-week avg).',
    fredId:'ICSA',
    current:null,
    fmt:v=>Math.round(v/1000)+'k'
  },
  SAHM: {
    tier:2, core:false,
    label:'Sahm Rule',
    desc:'SAHMREALTIME. Recession confirmation (>0.5).',
    fredId:'SAHMREALTIME',
    current:null,
    fmt:v=>v.toFixed(2)
  },
  PERMITS: {
    tier:2, core:false,
    label:'Building Permits 6m %Î”',
    desc:'PERMIT. Housing lead; non-core context.',
    fredId:'PERMIT',
    current:null,
    fmt:v=>v.toFixed(1)+'%'
  }
};

// Valuation inputs (manual)
const VALUATIONS = {
  BUFFETT: {
    label:'Buffett Indicator (MktCap/GDP)',
    danger:180,
    current:null,
    fmt:v=>v.toFixed(1)+'%'
  },
  CAPE: {
    label:'Shiller CAPE',
    danger:30,
    current:null,
    fmt:v=>v.toFixed(1)
  }
};

let cefiResult = null;
let radarChart = null;
let trendChart = null;

// --------- FRED CACHE LOADER ----------

async function loadFred() {
  const badge = document.getElementById('cache-badge');
  try {
    const res = await fetch('data/fred_cache.json', { cache:'no-store' });
    if (!res.ok) {
      badge.textContent = 'FRED cache: not found';
      return null;
    }
    const cache = await res.json();
    badge.textContent = 'FRED cache: ' + (cache.generated_at || 'loaded');
    return cache.series || null;
  } catch (e) {
    console.error('FRED cache error', e);
    badge.textContent = 'FRED cache: error';
    return null;
  }
}

function getObsValues(series, id) {
  const s = series && series[id];
  if (!s || !Array.isArray(s.observations)) return null;
  const vals = s.observations
    .map(o => Number(o.value))
    .filter(v => Number.isFinite(v));
  return vals.length ? vals : null;
}

function lastValue(series, id) {
  const s = series && series[id];
  if (!s || !Array.isArray(s.observations) || !s.observations.length) return null;
  for (let i = s.observations.length - 1; i >= 0; i--) {
    const v = Number(s.observations[i].value);
    if (Number.isFinite(v)) return v;
  }
  return null;
}

// 4-week avg of ICSA (last 4 obs)
function lastClaims4w(series) {
  const s = series && series['ICSA'];
  if (!s || !Array.isArray(s.observations) || s.observations.length < 4) return null;
  const slice = s.observations.slice(-4);
  const vals = slice.map(o => Number(o.value)).filter(Number.isFinite);
  if (vals.length < 4) return null;
  return vals.reduce((a,v)=>a+v,0)/vals.length;
}

// 12m drawdown from SP500 (if available)
function lastDrawdown12m(series) {
  const s = series && series['SP500'];
  if (!s || !Array.isArray(s.observations) || s.observations.length < 250) return null;
  const obs = s.observations;
  const last = Number(obs[obs.length-1].value);
  if (!Number.isFinite(last)) return null;
  const lastDate = new Date(obs[obs.length-1].date);
  if (Number.isNaN(lastDate)) return null;
  const cutoff = new Date(lastDate);
  cutoff.setFullYear(cutoff.getFullYear() - 1);

  let max = -Infinity;
  for (let i = 0; i < obs.length; i++) {
    const d = new Date(obs[i].date);
    const v = Number(obs[i].value);
    if (Number.isNaN(d) || !Number.isFinite(v)) continue;
    if (d >= cutoff && v > max) max = v;
  }
  if (!Number.isFinite(max) || max <= 0) return null;
  const dd = (max - last) / max * 100; // positive = drawdown
  return dd;
}

// Percentile helper (simple, fine for this size)
function percentile(sortedVals, p) {
  if (!sortedVals || !sortedVals.length) return null;
  const idx = (p / 100) * (sortedVals.length - 1);
  const lo = Math.floor(idx);
  const hi = Math.ceil(idx);
  if (lo === hi) return sortedVals[lo];
  return sortedVals[lo] + (sortedVals[hi] - sortedVals[lo]) * (idx - lo);
}

// Compute stress 0â€“100 from percentiles
function stressFromPercentiles(values, latest, direction) {
  if (!values || !values.length || !Number.isFinite(latest)) return null;
  const sorted = [...values].sort((a,b)=>a-b);
  const L = percentile(sorted, 5);
  const U = percentile(sorted, 95);
  if (!Number.isFinite(L) || !Number.isFinite(U) || U <= L) return null;

  let x = 0;
  if (direction === 'highBad') {
    x = (latest - L) / (U - L);
  } else { // lowBad
    x = (U - latest) / (U - L);
  }
  const s = Math.max(0, Math.min(1, x));
  return s * 100;
}

// --------- CEFI COMPUTATION ----------

function computeCEFI(series) {
  const notes = [];
  const drivers = {};
  let usedWeights = 0;
  let cefiRaw = 0;

  // Build each driver
  for (const [key, cfg] of Object.entries(CEFI_DRIVERS)) {
    let latest = null;
    let vals = null;

    if (cfg.transform === 'claims4w') {
      latest = lastClaims4w(series);
      vals = getObsValues(series, cfg.fredId);
    } else if (cfg.transform === 'dd12m') {
      latest = lastDrawdown12m(series); // already in %
      // For distribution, build from rolling 12m dd history (optional, keep simple: use all past dds)
      vals = null;
    } else {
      latest = lastValue(series, cfg.fredId);
      vals = getObsValues(series, cfg.fredId);
    }

    let stress = null;
    if (key === 'DD_12M') {
      if (latest != null) {
        // map 0â€“40% drawdown into 0â€“100 stress
        const s = latest <= 0 ? 0 : Math.min(1, latest / 40);
        stress = s * 100;
      }
    } else if (cfg.transform === 'claims4w') {
      if (latest != null && vals) {
        // use percentile distribution of weekly claims
        stress = stressFromPercentiles(vals, latest, 'highBad');
      }
    } else {
      stress = stressFromPercentiles(vals, latest, cfg.direction);
    }

    if (stress != null) {
      drivers[key] = { stress, latest, weight: cfg.weight };
      cefiRaw += stress * cfg.weight;
      usedWeights += cfg.weight;
    } else {
      drivers[key] = { stress: null, latest, weight: cfg.weight };
      notes.push(`Missing / weak data for ${key}.`);
    }
  }

  if (!usedWeights) {
    return {
      cefi: null,
      drivers,
      notes: ['No valid core drivers available.'],
      modelStatus: 'DEGRADED'
    };
  }

  // Rescale for missing drivers
  for (const key of Object.keys(drivers)) {
    if (drivers[key].stress != null) {
      drivers[key].contrib = (drivers[key].stress * drivers[key].weight) / usedWeights;
    } else {
      drivers[key].contrib = 0;
    }
  }
  let cefi = 0;
  for (const d of Object.values(drivers)) cefi += d.contrib;

  // YC + HY cap
  const yc = drivers.YC_10Y3M?.contrib || 0;
  const hy = drivers.HY_OAS?.contrib || 0;
  const ycHy = yc + hy;
  if (ycHy > MAX_CORE_POINTS) {
    const scale = MAX_CORE_POINTS / ycHy;
    drivers.YC_10Y3M.contrib *= scale;
    drivers.HY_OAS.contrib *= scale;
    cefi = 0;
    for (const d of Object.values(drivers)) cefi += d.contrib;
    notes.push(`YC+HY capped from ${ycHy.toFixed(2)} to ${(ycHy*scale).toFixed(2)} pts.`);
  }

  // Primary driver
  let primary = null, maxPts = -Infinity;
  for (const [k,v] of Object.entries(drivers)) {
    if (v.contrib > maxPts) {
      maxPts = v.contrib; primary = k;
    }
  }

  const available = Object.values(drivers).filter(d => d.stress != null).length;
  const modelStatus =
    available >= 3 ? 'NORMAL' :
    available >= 2 ? 'DEGRADED' : 'BROKEN';

  return {
    cefi: Math.max(0, Math.min(100, cefi)),
    drivers,
    primary,
    notes,
    modelStatus
  };
}

// --------- VALUATION STRESS ----------

function valuationStressScore() {
  const b = VALUATIONS.BUFFETT.current;
  const c = VALUATIONS.CAPE.current;
  let scores = [];

  if (Number.isFinite(b)) {
    if (b <= VALUATIONS.BUFFETT.danger) scores.push(0);
    else {
      const s = Math.min(1, (b - VALUATIONS.BUFFETT.danger) / VALUATIONS.BUFFETT.danger) * 100;
      scores.push(s);
    }
  }

  if (Number.isFinite(c)) {
    if (c <= VALUATIONS.CAPE.danger) scores.push(0);
    else {
      const s = Math.min(1, (c - VALUATIONS.CAPE.danger) / VALUATIONS.CAPE.danger) * 100;
      scores.push(s);
    }
  }

  if (!scores.length) return null;
  return scores.reduce((a,v)=>a+v,0) / scores.length;
}

// --------- UI BUILDERS ----------

function buildIndicatorTile(id, meta, cefiDrivers) {
  const isCore = !!meta.core;
  let val = meta.current;
  const driver = cefiDrivers && cefiDrivers[id];

  // If core, prefer latest from CEFI driver
  if (isCore && driver && driver.latest != null) {
    val = driver.latest;
  }

  const hasVal = Number.isFinite(val);
  const valueText = hasVal ? meta.fmt(val) : '--';

  // Stress shading using CEFI driver stress if present
  let stress = null;
  if (driver && driver.stress != null) stress = driver.stress;

  let cls = 'indicator';
  if (isCore) cls += ' core';
  if (stress != null) {
    if (stress >= 70) cls += ' danger';
    else if (stress >= 40) cls += ' warning';
  }

  const div = document.createElement('div');
  div.className = cls;

  let thresholdText = '';
  if (meta.threshold != null) {
    const op = meta.direction === 'below' ? '<' : '>';
    thresholdText = `Threshold: ${op} ${meta.fmt(meta.threshold)}`;
  }

  const srcText = meta.manual ? 'Manual input' : (meta.fredId ? 'Auto from FRED' : 'Derived');

  div.innerHTML = `
    <div class="indicator-header">
      <div class="indicator-name">${meta.label}</div>
      <div class="indicator-value">${valueText}</div>
    </div>
    <div class="indicator-threshold">${thresholdText}</div>
    <div class="indicator-threshold">${meta.desc}${!hasVal && !meta.manual ? ' (no usable data)' : ''}</div>
    <div class="source-tag">${srcText}${isCore ? ' â€¢ Feeds CEFI' : ''}</div>
    ${meta.manual ? `
      <div class="manual-input-row">
        <span>Set:</span>
        <input class="manual-input" type="number" step="0.1"
          data-manual-id="${id}" value="${hasVal ? val : ''}">
      </div>` : ''}
  `;
  return div;
}

function buildValuationTiles() {
  const box = document.getElementById('valuation-indicators');
  box.innerHTML = '';

  for (const [key, v] of Object.entries(VALUATIONS)) {
    const hasVal = Number.isFinite(v.current);
    const valText = hasVal ? v.fmt(v.current) : '--';
    const s = hasVal ? valuationStressScore() : null;

    let cls = 'indicator';
    if (s != null) {
      if (s >= 70) cls += ' danger';
      else if (s >= 40) cls += ' warning';
    }

    const div = document.createElement('div');
    div.className = cls;
    div.innerHTML = `
      <div class="indicator-header">
        <div class="indicator-name">${v.label}</div>
        <div class="indicator-value">${valText}</div>
      </div>
      <div class="indicator-threshold">Danger threshold: ${v.danger}</div>
      <div class="indicator-threshold">Manual input. Feeds Valuation Stress only.</div>
      <div class="source-tag">Manual</div>
      <div class="manual-input-row">
        <span>Set:</span>
        <input class="manual-input" type="number" step="0.1"
          data-val-key="${key}" value="${hasVal ? v.current : ''}">
      </div>
    `;
    box.appendChild(div);
  }

  // Update current labels
  const b = VALUATIONS.BUFFETT.current;
  const c = VALUATIONS.CAPE.current;
  document.getElementById('current-buffett-label').textContent =
    Number.isFinite(b) ? `Buffett: ${b.toFixed(1)}%` : 'Buffett: --';
  document.getElementById('current-cape-label').textContent =
    Number.isFinite(c) ? `CAPE: ${c.toFixed(1)}` : 'CAPE: --';

  // Bind inputs
  document.querySelectorAll('.manual-input[data-val-key]').forEach(inp => {
    inp.addEventListener('change', () => {
      const k = inp.dataset.valKey;
      const v = parseFloat(inp.value);
      if (!Number.isNaN(v)) {
        VALUATIONS[k].current = v;
        refresh();
      }
    });
  });
}

function renderIndicatorSections(cefiDrivers) {
  const t1 = document.getElementById('tier1-indicators');
  const t2 = document.getElementById('tier2-indicators');
  t1.innerHTML = '';
  t2.innerHTML = '';

  for (const [id, meta] of Object.entries(INDICATORS)) {
    const tile = buildIndicatorTile(id, meta, cefiDrivers);
    if (meta.tier === 1) t1.appendChild(tile);
    else t2.appendChild(tile);
  }

  // Bind manual LEI input
  document.querySelectorAll('.manual-input[data-manual-id]').forEach(inp => {
    inp.addEventListener('change', () => {
      const id = inp.dataset.manualId;
      const v = parseFloat(inp.value);
      if (!Number.isNaN(v)) {
        INDICATORS[id].current = v;
        refresh();
      }
    });
  });
}

// --------- COMPOSITE + UI ---------

function zoneForScore(v) {
  if (v == null || isNaN(v)) return 'none';
  if (v < 25) return 'green';
  if (v < 50) return 'lime';
  if (v < 70) return 'amber';
  if (v < 85) return 'red';
  return 'deepRed';
}

function zoneLabel(z) {
  if (z === 'green') return 'Low stress';
  if (z === 'lime') return 'Caution';
  if (z === 'amber') return 'Elevated';
  if (z === 'red') return 'High risk';
  if (z === 'deepRed') return 'Critical';
  return 'No signal';
}

function zoneColor(z) {
  if (z === 'green') return '#1ec28b';
  if (z === 'lime') return '#a3e635';
  if (z === 'amber') return '#ffc247';
  if (z === 'red') return '#fb923c';
  if (z === 'deepRed') return '#ff6070';
  return '#8b96b0';
}

function headlineProb(v) {
  if (v == null || isNaN(v)) return '--';
  if (v < 25) return '<10%';
  if (v < 40) return '10â€“20%';
  if (v < 55) return '20â€“30%';
  if (v < 70) return '30â€“50%';
  return '>50%';
}

function renderCompositeHeadline() {
  const scoreEl = document.getElementById('composite-score');
  const needle = document.getElementById('needle');
  const fill = document.getElementById('risk-fill');
  const regimeEl = document.getElementById('regime-label');
  const macroEl = document.getElementById('macro-cefi-display');
  const valEl = document.getElementById('valuation-risk-display');
  const recEl = document.getElementById('recession-risk-display');
  const qualityEl = document.getElementById('quality-display');
  const alert = document.getElementById('alert-banner');

  const macro = cefiResult && cefiResult.cefi != null ? cefiResult.cefi : null;
  const valStress = valuationStressScore();

  // Data coverage
  const expectedDrivers = Object.keys(CEFI_DRIVERS).length;
  const haveDrivers = cefiResult
    ? Object.values(cefiResult.drivers).filter(d => d.stress != null).length
    : 0;
  const coverage = expectedDrivers ? Math.round(haveDrivers / expectedDrivers * 100) : 0;
  qualityEl.textContent = expectedDrivers ? coverage + '%' : '--';

  // Macro CEFI display
  if (macro == null) {
    macroEl.textContent = '--';
  } else {
    macroEl.textContent = macro.toFixed(1);
  }

  // Valuation stress label
  if (valStress == null) {
    valEl.textContent = '--';
  } else if (valStress < 33) {
    valEl.textContent = 'Low ('+valStress.toFixed(0)+')';
  } else if (valStress < 66) {
    valEl.textContent = 'Moderate ('+valStress.toFixed(0)+')';
  } else {
    valEl.textContent = 'High ('+valStress.toFixed(0)+')';
  }

  // Composite headline: 70/30 if valuations present; else macro only
  let headline = macro;
  if (macro != null && valStress != null) {
    headline = macro * (1 - VALUATION_HEADLINE_WEIGHT) + valStress * VALUATION_HEADLINE_WEIGHT;
  }

  if (headline == null) {
    scoreEl.textContent = '--';
    fill.style.width = '0%';
    needle.style.transform = 'translateX(-50%) rotate(0deg)';
    regimeEl.textContent = 'COMPOSITE STRESS â€” insufficient data';
    recEl.textContent = '--';
    alert.textContent = 'No robust composite: fix missing FRED series and manual valuation inputs.';
    return;
  }

  const v = Math.max(0, Math.min(100, Math.round(headline)));
  scoreEl.textContent = v;
  fill.style.width = v + '%';
  const angle = (v / 100) * 360;
  needle.style.transform = `translateX(-50%) rotate(${angle}deg)`;

  const z = zoneForScore(v);
  const label = zoneLabel(z);
  regimeEl.textContent = `COMPOSITE STRESS â€” ${label}`;
  recEl.textContent = headlineProb(v);

  if (z === 'green') {
    alert.textContent =
      `Composite = ${v}. Macro & valuations not clustered in historic danger zones on your inputs.`;
  } else if (z === 'lime') {
    alert.textContent =
      `Composite = ${v}. Early tension; track which core driver is dominating before positioning.`;
  } else if (z === 'amber') {
    alert.textContent =
      `Composite = ${v}. Elevated regime: multiple levers warm; historically where risk mispricing matters.`;
  } else if (z === 'red') {
    alert.textContent =
      `Composite = ${v}. High fragility; regimes like this have often preceded recessions or major drawdowns.`;
  } else {
    alert.textContent =
      `Composite = ${v}. Critical cluster; treat as crash/recession watch, not a guarantee.`;
  }
}

function renderRadar() {
  const ctx = document.getElementById('risk-radar').getContext('2d');
  if (radarChart) radarChart.destroy();
  if (!cefiResult) return;

  const labels = [];
  const data = [];

  for (const [key, cfg] of Object.entries(CEFI_DRIVERS)) {
    const d = cefiResult.drivers[key];
    if (d && d.stress != null) {
      labels.push(key);
      data.push(Math.round(d.stress));
    }
  }

  const val = valuationStressScore();
  if (val != null) {
    labels.push('Valuations');
    data.push(Math.round(val));
  }

  if (!labels.length) return;

  radarChart = new Chart(ctx, {
    type:'radar',
    data:{
      labels,
      datasets:[{
        label:'Normalized Stress (0â€“100)',
        data,
        borderColor:'#6b9eff',
        backgroundColor:'rgba(107,158,255,0.18)',
        pointRadius:2
      }]
    },
    options:{
      plugins:{legend:{display:false}},
      scales:{
        r:{
          suggestedMin:0,
          suggestedMax:100,
          ticks:{display:false},
          grid:{color:'rgba(255,255,255,0.08)'},
          angleLines:{color:'rgba(255,255,255,0.04)'},
          pointLabels:{color:'#8b96b0',font:{size:7}}
        }
      }
    }
  });
}

function renderTrend(history) {
  const ctx = document.getElementById('cefi-trend').getContext('2d');
  if (trendChart) trendChart.destroy();
  if (!history || !history.length) return;

  const labels = history.map(p => p.date);
  const vals = history.map(p => p.cefi);

  trendChart = new Chart(ctx, {
    type:'line',
    data:{
      labels,
      datasets:[{
        label:'Macro CEFI',
        data:vals,
        borderColor:'#6b9eff',
        backgroundColor:'rgba(107,158,255,0.12)',
        fill:true,
        tension:0.28,
        pointRadius:0
      }]
    },
    options:{
      plugins:{
        legend:{display:false},
        title:{
          display:true,
          text:'CEFI history (derived from core drivers)',
          color:'#e8eeff',
          font:{size:10}
        }
      },
      scales:{
        x:{ticks:{display:false},grid:{display:false}},
        y:{
          min:0,max:100,
          ticks:{color:'#8b96b0',font:{size:8}},
          grid:{color:'rgba(255,255,255,0.08)'}
        }
      }
    }
  });
}

function updateInsight() {
  const el = document.getElementById('insight-text');
  if (!cefiResult || cefiResult.cefi == null) {
    el.textContent = 'No robust macro CEFI yet. Confirm FRED coverage and manual valuation inputs.';
    return;
  }
  const v = cefiResult.cefi;
  const val = valuationStressScore();
  const primary = cefiResult.primary || 'none';

  if (v < 25 && (val == null || val < 33)) {
    el.textContent = 'Benign setup: macro and valuations both reasonable. Historically low fragility.';
  } else if (v < 40 && val != null && val >= 66) {
    el.textContent = 'Macro ok but valuations stretched. Vulnerable to shocks or policy error.';
  } else if (v >= 50 && v < 70) {
    el.textContent = `Elevated macro fragility driven mainly by ${primary}. Use tilts, not panic.`;
  } else if (v >= 70 && val != null && val >= 66) {
    el.textContent = `High macro fragility plus rich valuations. This combination has overlapped past crisis regimes.`;
  } else {
    el.textContent = 'Mixed signals. Use radar and tiles; act on clusters, not single spikes.';
  }
}

// --------- MASTER REFRESH ----------

function refresh() {
  // recompute valuation labels and tiles
  buildValuationTiles();
  renderCompositeHeadline();
  renderRadar();
  updateInsight();
}

// --------- INIT ----------

document.addEventListener('DOMContentLoaded', async () => {
  const series = await loadFred();

  // Populate core indicator latests from series
  if (series) {
    // Map INDICATORS from FRED
    for (const [id, meta] of Object.entries(INDICATORS)) {
      if (meta.fredId) {
        const v = lastValue(series, meta.fredId);
        if (v != null) meta.current = v;
      }
      if (id === 'PERMITS') {
        const dd = lastDrawdown12m({ SP500: series.PERMIT }); // placeholder; permits %Î” handled in CEFI only if needed
      }
    }
  }

  // Compute CEFI from series
  if (series) {
    cefiResult = computeCEFI(series);
  } else {
    cefiResult = {
      cefi: null,
      drivers: {},
      notes:['No FRED series loaded'],
      modelStatus:'BROKEN'
    };
  }

  // Build tiles based on CEFI drivers
  renderIndicatorSections(cefiResult.drivers);

  // Wire manual valuation inputs after first render
  buildValuationTiles();

  // Trend history: build from CEFI drivers if there is enough history
  let history = [];
  if (series) {
    const ycVals = getObsValues(series, 'T10Y3M');
    const hyVals = getObsValues(series, 'BAMLH0A0HYM2');
    if (ycVals && hyVals && ycVals.length === hyVals.length) {
      // simple back-series using YC & HY only, for visual context
      const len = Math.min(120, ycVals.length);
      const sliceStart = ycVals.length - len;
      for (let i = sliceStart; i < ycVals.length; i++) {
        const point = computeCEFI(series); // strict backfill would recompute per date; omitted for simplicity
        if (point && point.cefi != null) {
          history.push({ date: 't-'+(ycVals.length-i), cefi: point.cefi });
          break; // do not fake full history â€“ one point is enough to show logic without lying
        }
      }
    }
  }
  renderTrend(history);

  renderCompositeHeadline();
  renderRadar();
  updateInsight();

  // Inputs / coverage badge
  const totalInputs =
    Object.keys(CEFI_DRIVERS).length +
    Object.keys(VALUATIONS).length;
  const usedInputs =
    Object.values(cefiResult.drivers || {}).filter(d => d.stress != null).length +
    Object.values(VALUATIONS).filter(v => Number.isFinite(v.current)).length;
  document.getElementById('inputs-badge').textContent =
    `Inputs: ${usedInputs}/${totalInputs} contributing`;
});
</script>
</body>
</html>
