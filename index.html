<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Economic Crash Radar Pro v7</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg:#0a0e1a;
      --panel:#12182b;
      --text:#e8eeff;
      --muted:#8b96b0;
      --accent:#6b9eff;
      --accent-soft:#8fb4ff;
      --green:#1ec28b;
      --amber:#ffc247;
      --red:#ff6070;
      --radius-lg:16px;
      --shadow-soft:0 8px 24px rgba(0,0,0,0.45);
      --font-main:-apple-system,BlinkMacSystemFont,"Segoe UI",system-ui,sans-serif;
    }

    *{margin:0;padding:0;box-sizing:border-box;}

    body{
      background:var(--bg);
      color:var(--text);
      font:15px/1.6 var(--font-main);
      -webkit-font-smoothing:antialiased;
      padding:18px 12px 40px;
    }

    .container{max-width:1440px;margin:0 auto;}
    .header{text-align:center;margin-bottom:18px;}

    h1{
      font-size:clamp(30px,6vw,46px);
      font-weight:800;
      margin-bottom:6px;
      background:linear-gradient(135deg,var(--text),var(--accent-soft));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
    }

    .subtitle{
      color:var(--muted);
      font-size:0.95rem;
    }

    .meta-badges{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:6px;
      margin-top:8px;
      font-size:0.7rem;
      color:var(--muted);
    }

    .badge{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.02);
    }

    .alert-banner{
      margin:16px auto 18px;
      padding:10px 12px;
      max-width:900px;
      border-radius:10px;
      background:linear-gradient(135deg,rgba(107,158,255,0.08),rgba(139,187,255,0.02));
      border:1px solid rgba(107,158,255,0.25);
      font-size:0.8rem;
      color:var(--text);
    }

    .dashboard{
      display:grid;
      grid-template-columns:280px 1fr;
      gap:16px;
      align-items:flex-start;
    }

    .sidebar{
      background:var(--panel);
      border-radius:var(--radius-lg);
      padding:16px 14px 14px;
      box-shadow:var(--shadow-soft);
    }

    .main-content{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:14px;
    }

    .card{
      background:var(--panel);
      border-radius:var(--radius-lg);
      padding:14px 12px 12px;
      box-shadow:var(--shadow-soft);
    }

    .card-title{
      font-size:1rem;
      font-weight:700;
      color:var(--accent-soft);
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:8px;
    }
    .card-title .icon{font-size:1.1rem;}

    .gauge-container{text-align:center;margin-bottom:8px;}
    .gauge{
      position:relative;
      width:190px;
      height:190px;
      margin:0 auto;
    }
    .gauge-background{
      position:absolute;
      inset:0;
      border-radius:50%;
      background:conic-gradient(
        var(--green) 0deg 108deg,
        var(--amber) 108deg 216deg,
        var(--red) 216deg 360deg
      );
      opacity:0.28;
    }
    .gauge-center{
      position:absolute;
      top:10%;
      left:10%;
      width:80%;
      height:80%;
      border-radius:50%;
      background:var(--panel);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    .gauge-score{
      font-size:2.4rem;
      font-weight:800;
    }
    .gauge-label{
      font-size:0.7rem;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.08em;
      margin-top:2px;
      text-align:center;
    }
    .gauge-needle{
      position:absolute;
      bottom:50%;
      left:50%;
      width:3px;
      height:46%;
      background:var(--accent);
      transform-origin:bottom center;
      transform:translateX(-50%) rotate(0deg);
      border-radius:4px 4px 0 0;
      transition:transform 0.9s ease;
    }

    .risk-meter{margin-top:6px;}
    .risk-bar{
      height:6px;
      border-radius:4px;
      background:rgba(255,255,255,0.1);
      overflow:hidden;
    }
    .risk-fill{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,var(--green),var(--amber),var(--red));
      transition:width 0.8s ease;
    }
    .risk-labels{
      display:flex;
      justify-content:space-between;
      margin-top:4px;
      font-size:0.65rem;
      color:var(--muted);
    }

    .status-grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px;
      margin-top:10px;
    }
    .status-item{
      padding:7px 6px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      font-size:0.7rem;
    }
    .status-label{
      color:var(--muted);
      font-size:0.66rem;
    }
    .status-value{
      font-weight:700;
      font-size:0.95rem;
      margin-top:1px;
    }

    .indicator-grid{
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(220px,1fr));
      gap:7px;
      margin-top:4px;
    }
    .indicator{
      padding:7px 7px 6px;
      background:rgba(255,255,255,0.03);
      border-radius:8px;
      border-left:3px solid var(--green);
      font-size:0.7rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .indicator:hover {
      background:rgba(255,255,255,0.05);
      transform: translateY(-1px);
    }
    .indicator.warning{border-left-color:var(--amber);}
    .indicator.danger{border-left-color:var(--red);}
    .indicator.expanded {
      grid-column: 1 / -1;
      background:rgba(255,255,255,0.04);
    }

    .indicator-header{
      display:flex;
      justify-content:space-between;
      gap:4px;
      align-items:baseline;
      margin-bottom:2px;
    }
    .indicator-name{
      font-weight:600;
      font-size:0.78rem;
    }
    .indicator-value{
      font-weight:700;
      font-size:0.9rem;
    }
    .indicator-threshold{
      color:var(--muted);
      font-size:0.62rem;
      margin-top:1px;
    }
    .source-tag{
      display:inline-block;
      margin-top:3px;
      padding:2px 5px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.14);
      font-size:0.58rem;
      color:var(--muted);
    }

    .manual-input-row{
      display:flex;
      flex-direction:column;
      gap:3px;
      margin-top:4px;
      font-size:0.6rem;
    }
    .manual-input-row span{
      color:var(--muted);
      font-size:0.62rem;
    }
    .manual-input{
      width:100%;
      padding:8px 8px;
      min-height:44px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(0,0,0,0.5);
      color:var(--text);
      font-size:0.75rem;
      outline:none;
    }
    .manual-input:focus{
      border-color:var(--accent);
      box-shadow:0 0 4px var(--accent);
    }

    .valuation-comparison{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(150px,1fr));
      gap:6px;
      margin-top:8px;
      font-size:0.68rem;
    }
    .valuation-item{
      padding:6px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      text-align:center;
    }
    .valuation-item.current{
      border:1px solid var(--red);
      background:rgba(255,96,112,0.05);
    }
    .valuation-title{
      font-weight:600;
      margin-bottom:2px;
    }
    .valuation-metric{margin:1px 0;}
    .valuation-outcome{
      margin-top:2px;
      color:var(--muted);
    }

    .insight-card{
      margin-top:6px;
      padding:6px 7px;
      border-radius:8px;
      background:linear-gradient(135deg,rgba(107,158,255,0.10),rgba(10,14,26,1));
      border:1px solid rgba(107,158,255,0.25);
      font-size:0.7rem;
    }
    .chart-container{margin-top:4px;}

    .history-grid{
      margin-top:6px;
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
      gap:5px;
      font-size:0.66rem;
    }
    .history-item{
      padding:5px;
      border-radius:8px;
      background:rgba(255,255,255,0.02);
    }
    .history-title{
      font-weight:600;
      margin-bottom:1px;
      font-size:0.7rem;
    }

    /* New styles for enhancements */
    .data-source-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 2px;
    }
    
    .data-source-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      display: inline-block;
    }
    
    .data-source-auto {
      background-color: var(--green);
    }
    
    .data-source-manual {
      background-color: var(--amber);
    }
    
    .data-source-missing {
      background-color: var(--muted);
    }

    .data-age-label {
      font-size:0.6rem;
      margin-top:1px;
    }
    .data-age-fresh { color: var(--green); }
    .data-age-stale { color: var(--amber); }
    .data-age-old   { color: var(--red); }

    .refresh-controls {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn:hover {
      background: rgba(255,255,255,0.1);
    }
    
    .btn-primary {
      background: var(--accent);
      border-color: var(--accent);
    }
    
    .btn-primary:hover {
      background: var(--accent-soft);
    }
    
    .export-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    
    .export-section h3 {
      font-size: 0.8rem;
      margin-bottom: 6px;
      color: var(--accent-soft);
    }
    
    .export-options {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    
    .export-btn {
      padding: 4px 8px;
      font-size: 0.65rem;
    }
    
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 14, 26, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .loading-overlay.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255,255,255,0.1);
      border-left: 4px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    
    .loading-text {
      font-size: 0.9rem;
      color: var(--text);
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .indicator-tooltip {
      position: absolute;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 8px;
      font-size: 0.7rem;
      max-width: 250px;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    .indicator-tooltip.active {
      opacity: 1;
    }

    /* History chart styles */
    .indicator-history {
      margin-top: 10px;
      display: none;
    }
    
    .indicator.expanded .indicator-history {
      display: block;
    }
    
    .history-chart-container {
      height: 160px;
      margin-top: 8px;
    }
    
    .history-period-selector {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
      justify-content: center;
    }
    
    .period-btn {
      padding: 3px 8px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.03);
      color: var(--muted);
      font-size: 0.6rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .period-btn.active {
      background: var(--accent);
      color: var(--text);
      border-color: var(--accent);
    }
    
    .history-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-top: 8px;
      font-size: 0.65rem;
    }
    
    .history-stat {
      padding: 4px;
      background: rgba(255,255,255,0.02);
      border-radius: 4px;
      text-align: center;
    }
    
    .history-stat-value {
      font-weight: 700;
      font-size: 0.75rem;
      margin-top: 2px;
    }
    
    .history-stat-label {
      color: var(--muted);
      font-size: 0.55rem;
    }

    .no-data-message {
      text-align: center;
      color: var(--muted);
      font-size: 0.7rem;
      padding: 20px;
    }

    /* Scenario panel */
    .scenario-grid {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
      gap:6px;
      margin-top:8px;
      font-size:0.68rem;
    }
    .scenario-item {
      padding:6px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
    }
    .scenario-item label {
      display:block;
      font-size:0.7rem;
      margin-bottom:2px;
      color:var(--muted);
    }
    .scenario-toggle-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-top:4px;
      font-size:0.7rem;
    }

    @media(max-width:900px){
      body{padding:14px 8px 26px;}
      .dashboard{grid-template-columns:1fr;}
      .main-content{grid-template-columns:1fr;}
      .sidebar{order:-1;}
      .export-options {
        flex-direction: column;
      }
      .history-stats {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>âš¡ Economic Crash Radar Pro v7</h1>
    <div class="subtitle">
      10 macro indicators (9 auto via FRED, 1 manual) + 2 valuations. Composite with smoothed stress bands (no binary cliffs).
    </div>
    <div class="meta-badges">
      <div class="badge" id="cache-badge">FRED cache: not loaded</div>
      <div class="badge">Manual: LEI 6m Î”, Buffett, CAPE</div>
      <div class="badge">Auto: Curve, HY, NFCI, UMich, M2, INDPRO, Permits, Claims, Sahm</div>
      <div class="badge" id="inputs-badge">Inputs: 0/12 populated</div>
    </div>
    <div class="refresh-controls">
      <button class="btn btn-primary" id="refresh-data">Refresh Data</button>
      <button class="btn" id="reset-inputs">Reset Inputs</button>
      <button class="btn" id="show-help">Help & Documentation</button>
    </div>
  </div>

  <div class="alert-banner" id="alert-banner">
    Composite = 70% macro block + 30% valuation block when both available; otherwise uses whichever block is populated.
  </div>

  <div class="dashboard">
    <!-- SIDEBAR -->
    <div class="sidebar">
      <div class="gauge-container">
        <div class="gauge">
          <div class="gauge-background"></div>
          <div class="gauge-center">
            <div class="gauge-score" id="composite-score">--</div>
            <div class="gauge-label" id="regime-label">COMPOSITE STRESS</div>
          </div>
          <div class="gauge-needle" id="needle"></div>
        </div>
        <div class="risk-meter">
          <div class="risk-bar">
            <div class="risk-fill" id="risk-fill"></div>
          </div>
          <div class="risk-labels">
            <span>Low (0-30)</span>
            <span>Med (30-50)</span>
            <span>High (50-70)</span>
            <span>Critical (70-100)</span>
          </div>
        </div>
      </div>
      <div class="status-grid">
        <div class="status-item">
          <div class="status-label">Recession Probability (12â€“18m)</div>
          <div class="status-value" id="recession-risk-display">--</div>
          <div class="indicator-threshold">Bucketed from composite.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Valuation Risk</div>
          <div class="status-value" id="valuation-risk-display">--</div>
          <div class="indicator-threshold">Buffett + CAPE stress.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Labor Market Stress</div>
          <div class="status-value" id="labor-risk-display">--</div>
          <div class="indicator-threshold">Claims + Sahm.</div>
        </div>
        <div class="status-item">
          <div class="status-label">Data Coverage</div>
          <div class="status-value" id="quality-display">--</div>
          <div class="indicator-threshold">Filled indicators / total.</div>
        </div>
      </div>
      
      <div class="export-section">
        <h3>Export & Share</h3>
        <div class="export-options">
          <button class="btn export-btn" id="export-pdf">PDF Report</button>
          <button class="btn export-btn" id="export-csv">CSV Data</button>
          <button class="btn export-btn" id="export-snapshot">Snapshot</button>
          <button class="btn export-btn" id="share-link">Share Link</button>
        </div>
      </div>
    </div>

    <!-- MAIN -->
    <div class="main-content">
      <div class="card">
        <div class="card-title"><span class="icon">ðŸ“Š</span>Tier 1 Leading Indicators</div>
        <div class="indicator-grid" id="tier1-indicators"></div>
      </div>

      <div class="card">
        <div class="card-title"><span class="icon">ðŸ“ˆ</span>Tier 2 Confirming Indicators</div>
        <div class="indicator-grid" id="tier2-indicators"></div>
      </div>

      <div class="card">
        <div class="card-title"><span class="icon">ðŸ’°</span>Valuation Indicators</div>
        <div class="indicator-grid" id="valuation-indicators"></div>

        <div class="valuation-comparison">
          <div class="valuation-item">
            <div class="valuation-title">2000 Dot-com</div>
            <div class="valuation-metric">CAPE â‰ˆ 44</div>
            <div class="valuation-metric">Buffett â‰ˆ 140â€“160%</div>
            <div class="valuation-outcome">Severe drawdown.</div>
          </div>
          <div class="valuation-item">
            <div class="valuation-title">2007 Pre-GFC</div>
            <div class="valuation-metric">CAPE â‰ˆ 27</div>
            <div class="valuation-metric">Buffett â‰ˆ 105%</div>
            <div class="valuation-outcome">Crisis.</div>
          </div>
          <div class="valuation-item">
            <div class="valuation-title">2021 Peak</div>
            <div class="valuation-metric">CAPE â‰ˆ 38</div>
            <div class="valuation-metric">Buffett â‰ˆ 195%</div>
            <div class="valuation-outcome">2022 correction.</div>
          </div>
          <div class="valuation-item current">
            <div class="valuation-title">Current (your inputs)</div>
            <div class="valuation-metric" id="current-buffett-label">Buffett: --</div>
            <div class="valuation-metric" id="current-cape-label">CAPE: --</div>
            <div class="valuation-outcome">Reflects manual entries.</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title"><span class="icon">ðŸ•’</span>History, Radar & Prior Regimes</div>
        <div class="chart-container">
          <canvas id="market-trend" height="130"></canvas>
        </div>
        <div class="chart-container">
          <canvas id="risk-radar" height="140"></canvas>
        </div>
        <div class="insight-card">
          <strong>Insight:</strong>
          <span id="insight-text">
            Once populated, this compares today's configuration to prior stress regimes.
          </span>
        </div>
        <div class="history-grid">
          <div class="history-item">
            <div class="history-title">1973â€“75 / early 80s</div>
            <div>Curve inversion + energy shocks + weak leads.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2000â€“02</div>
            <div>Extreme valuations, tightening, growth rollover.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2007â€“09</div>
            <div>Housing + credit + inversion aligned.</div>
          </div>
          <div class="history-item">
            <div class="history-title">2020</div>
            <div>External shock; indicator behavior distinct.</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title"><span class="icon">ðŸ§ª</span>Scenario Override (Beta)</div>
        <div class="scenario-toggle-row">
          <span>Apply scenario overrides to composite</span>
          <label>
            <input type="checkbox" id="scenario-toggle" />
            Use scenario values
          </label>
        </div>
        <div class="scenario-grid">
          <div class="scenario-item">
            <label for="scenario-LEI">LEI 6m %Î”</label>
            <input class="manual-input" id="scenario-LEI" type="number" step="0.1" />
          </div>
          <div class="scenario-item">
            <label for="scenario-YIELD_CURVE">Yield Curve (10yâ€“3m, pp)</label>
            <input class="manual-input" id="scenario-YIELD_CURVE" type="number" step="0.01" />
          </div>
          <div class="scenario-item">
            <label for="scenario-CREDIT_SPREAD">HY OAS (pp)</label>
            <input class="manual-input" id="scenario-CREDIT_SPREAD" type="number" step="0.01" />
          </div>
          <div class="scenario-item">
            <label for="scenario-M2_GROWTH">M2 YoY %</label>
            <input class="manual-input" id="scenario-M2_GROWTH" type="number" step="0.1" />
          </div>
          <div class="scenario-item">
            <label for="scenario-BUFFETT">Buffett %</label>
            <input class="manual-input" id="scenario-BUFFETT" type="number" step="0.1" />
          </div>
          <div class="scenario-item">
            <label for="scenario-SHILLER_PE">CAPE</label>
            <input class="manual-input" id="scenario-SHILLER_PE" type="number" step="0.1" />
          </div>
        </div>
        <div class="indicator-threshold" style="margin-top:6px;">
          Scenario overrides do not overwrite stored values; they are applied only to the composite calculation while enabled.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loading-overlay">
  <div class="loading-spinner"></div>
  <div class="loading-text" id="loading-text">Loading data...</div>
</div>

<!-- Tooltip -->
<div class="indicator-tooltip" id="indicator-tooltip"></div>

<script>
'use strict';

const MACRO_BLOCK_WEIGHT = 0.70;
const VALUATION_BLOCK_WEIGHT = 0.30;
const WARN_MAX = 30;
const MANUAL_STORAGE_KEY = 'crashRadarManualInputs_v1';

let cacheAgeDays = null;
let expandedIndicator = null;
let fredCache = null;            // raw cache from fred_cache.json
let historicalData = {};         // processed time series per fredId
let indicatorCharts = {};        // per-indicator Chart.js instances
let charts = { trend:null, radar:null };
let compositeScore = null;

// Scenario mode
let scenarioMode = false;
let scenarioOverrides = {};

// Expected cadence (days) for freshness labelling
const CADENCE_DAYS = {
  T10Y3M: 10,
  BAMLH0A0HYM2: 10,
  NFCI: 7,
  UMCSENT: 45,
  M2SL: 60,
  INDPRO: 60,
  PERMIT: 60,
  ICSA: 10,
  SAHMREALTIME: 30
};

const INDICATORS = {
  LEI: {
    tier:1,
    label:'Conference Board LEI 6m %Î”',
    weight:0.15,
    threshold:-3.5,
    direction:'below',
    span:3.0,
    fromFred:false,
    fredId:null,
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(1) + '%',
    desc:'Manual. 6m % change in LEI. â‰¤ -3.5% has preceded most post-1960 recessions.',
    tooltip: 'The Conference Board Leading Economic Index (LEI) 6-month percent change. A value â‰¤ -3.5% has historically preceded most recessions since 1960.'
  },
  YIELD_CURVE: {
    tier:1,
    label:'Yield Curve (10yâ€“3m)',
    weight:0.12,
    threshold:0.0,
    direction:'below',
    span:1.0,
    fromFred:true,
    fredId:'T10Y3M',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(2) + ' pp',
    desc:'10yâ€“3m spread. Inversions (â‰¤0) are classic recession leads.',
    tooltip: '10-year minus 3-month Treasury yield spread. Inversions (â‰¤0) have preceded most US recessions since 1950.'
  },
  CREDIT_SPREAD: {
    tier:1,
    label:'HY Credit Spread',
    weight:0.10,
    threshold:5.0,
    direction:'above',
    span:3.0,
    fromFred:true,
    fredId:'BAMLH0A0HYM2',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(2) + ' pp',
    desc:'US HY OAS. >5% = stress, >8% = crisis-like conditions.',
    tooltip: 'High-yield corporate bond option-adjusted spread. >5% indicates financial stress; >8% signals crisis-like conditions.'
  },
  FIN_STRESS: {
    tier:1,
    label:'Financial Stress (NFCI)',
    weight:0.08,
    threshold:0.0,
    direction:'above',
    span:0.5,
    fromFred:true,
    fredId:'NFCI',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(2),
    desc:'Chicago Fed NFCI. >0 indicates tighter-than-average conditions.',
    tooltip: 'Chicago Fed National Financial Conditions Index. Positive values indicate tighter-than-average financial conditions.'
  },
  CONSUMER_SENTIMENT: {
    tier:1,
    label:'UMich Sentiment',
    weight:0.08,
    threshold:60.0,
    direction:'below',
    span:25.0,
    fromFred:true,
    fredId:'UMCSENT',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(1),
    desc:'Deep pessimism. Sustained <60 readings cluster around recessions.',
    tooltip: 'University of Michigan Consumer Sentiment Index. Sustained readings <60 typically cluster around recessions.'
  },
  M2_GROWTH: {
    tier:1,
    label:'M2 Growth YoY',
    weight:0.08,
    threshold:0.0,
    direction:'below',
    span:6.0,
    fromFred:true,
    fredId:'M2SL',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(1) + '%',
    desc:'YoY growth from M2SL. â‰¤0% is historically rare and restrictive.',
    tooltip: 'Year-over-year M2 money supply growth. â‰¤0% is historically rare and indicates restrictive monetary conditions.'
  },
  INDUSTRIAL_PRODUCTION: {
    tier:2,
    label:'Industrial Production YoY',
    weight:0.07,
    threshold:0.0,
    direction:'below',
    span:5.0,
    fromFred:true,
    fredId:'INDPRO',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(1) + '%',
    desc:'YoY change. Sustained contraction confirms downturn.',
    tooltip: 'Year-over-year industrial production growth. Sustained contraction confirms broader economic downturn.'
  },
  BUILDING_PERMITS: {
    tier:2,
    label:'Building Permits 6m %Î”',
    weight:0.07,
    threshold:-10.0,
    direction:'below',
    span:10.0,
    fromFred:true,
    fredId:'PERMIT',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(1) + '%',
    desc:'6m % change. Sharp drops lead housing & broader weakness.',
    tooltip: '6-month percent change in building permits. Sharp drops typically lead housing market weakness and broader economic slowdown.'
  },
  INITIAL_CLAIMS: {
    tier:2,
    label:'Initial Claims 4wk MA (k)',
    weight:0.08,
    threshold:325,
    direction:'above',
    span:150,
    fromFred:true,
    fredId:'ICSA',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => Math.round(v) + 'k',
    desc:'4-week avg in thousands. >325k consistent with labor market stress.',
    tooltip: '4-week moving average of initial jobless claims in thousands. >325k is consistent with labor market stress.'
  },
  SAHM_RULE: {
    tier:2,
    label:'Sahm Rule (pp)',
    weight:0.07,
    threshold:0.50,
    direction:'above',
    span:0.5,
    fromFred:true,
    fredId:'SAHMREALTIME',
    current:null,
    lastObsDate:null,
    dataAgeDays:null,
    format:v => v.toFixed(2),
    desc:'â‰¥0.50 triggers real-time recession signal.',
    tooltip: 'Sahm Rule Recession Indicator. A reading â‰¥0.50 percentage points triggers a real-time recession signal.'
  }
};

const VALUATIONS = {
  BUFFETT: {
    label:'Buffett Indicator (MktCap/GDP)',
    weight:0.50,
    danger:200,
    current:null,
    format:v => v.toFixed(1) + '%',
    desc:'>150% stretched; >200% historically extreme.',
    tooltip: 'Total stock market capitalization to GDP ratio. >150% indicates stretched valuations; >200% is historically extreme.'
  },
  SHILLER_PE: {
    label:'Shiller CAPE',
    weight:0.50,
    danger:30,
    current:null,
    format:v => v.toFixed(1),
    desc:'>25 elevated; >30 associated with poor long-run returns.',
    tooltip: 'Cyclically Adjusted Price-to-Earnings ratio. >25 indicates elevated valuations; >30 is associated with poor long-term returns.'
  }
};

// === Utility: Loading overlay and tooltip ===
function showLoading(message = 'Loading data...') {
  const overlay = document.getElementById('loading-overlay');
  const text = document.getElementById('loading-text');
  if (overlay && text) {
    text.textContent = message;
    overlay.classList.add('active');
  }
}

function hideLoading() {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    overlay.classList.remove('active');
  }
}

function showTooltip(content, x, y) {
  const tooltip = document.getElementById('indicator-tooltip');
  if (!tooltip) return;
  tooltip.innerHTML = content;
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
  tooltip.classList.add('active');
}

function hideTooltip() {
  const tooltip = document.getElementById('indicator-tooltip');
  if (tooltip) tooltip.classList.remove('active');
}

// === Data processing helpers (single source of truth) ===
function calculateYoYGrowth(observations) {
  const result = [];
  if (!Array.isArray(observations)) return result;

  for (let i = 12; i < observations.length; i++) {
    const current = parseFloat(observations[i].value);
    const yearAgo = parseFloat(observations[i - 12].value);
    if (!isNaN(current) && !isNaN(yearAgo) && yearAgo !== 0) {
      const growth = ((current - yearAgo) / yearAgo) * 100;
      result.push({ date: observations[i].date, value: growth });
    }
  }
  return result;
}

function calculateRollingPercentChange(observations, months) {
  const result = [];
  if (!Array.isArray(observations)) return result;

  for (let i = months; i < observations.length; i++) {
    const current = parseFloat(observations[i].value);
    const periodAgo = parseFloat(observations[i - months].value);
    if (!isNaN(current) && !isNaN(periodAgo) && periodAgo !== 0) {
      const change = ((current - periodAgo) / periodAgo) * 100;
      result.push({ date: observations[i].date, value: change });
    }
  }
  return result;
}

function calculateMovingAverage(observations, periods) {
  const result = [];
  if (!Array.isArray(observations)) return result;

  for (let i = periods - 1; i < observations.length; i++) {
    let sum = 0;
    let count = 0;
    for (let j = 0; j < periods; j++) {
      const value = parseFloat(observations[i - j].value);
      if (!isNaN(value)) {
        sum += value;
        count++;
      }
    }
    if (count === periods) {
      result.push({
        date: observations[i].date,
        value: sum / periods / 1000 // thousands
      });
    }
  }
  return result;
}

// Process a FRED series once and reuse everywhere
function processFredSeries(fredId, seriesData) {
  if (!seriesData || !Array.isArray(seriesData.observations)) return [];
  const obs = seriesData.observations;

  if (fredId === 'M2SL') {
    return calculateYoYGrowth(obs);
  } else if (fredId === 'INDPRO') {
    return calculateYoYGrowth(obs);
  } else if (fredId === 'PERMIT') {
    return calculateRollingPercentChange(obs, 6);
  } else if (fredId === 'ICSA') {
    return calculateMovingAverage(obs, 4);
  } else {
    return obs.map(o => ({
      date: o.date,
      value: parseFloat(o.value)
    })).filter(o => !isNaN(o.value));
  }
}

// === Scenario helpers ===
function getScenarioValue(key, baseValue) {
  if (!scenarioMode) return baseValue;
  if (!Object.prototype.hasOwnProperty.call(scenarioOverrides, key)) return baseValue;
  const v = scenarioOverrides[key];
  return Number.isFinite(v) ? v : baseValue;
}

// === Indicator expansion & history ===
function toggleIndicatorExpansion(key, type = 'indicator') {
  const selector = type === 'valuation' ? `[data-val-card="${key}"]` : `[data-ind-card="${key}"]`;
  const element = document.querySelector(selector);
  if (!element) return;

  if (expandedIndicator === key) {
    element.classList.remove('expanded');
    expandedIndicator = null;
    if (indicatorCharts[key]) {
      indicatorCharts[key].destroy();
      delete indicatorCharts[key];
    }
  } else {
    if (expandedIndicator) {
      const prevElement = document.querySelector(
        type === 'valuation' ? `[data-val-card="${expandedIndicator}"]` : `[data-ind-card="${expandedIndicator}"]`
      );
      if (prevElement) prevElement.classList.remove('expanded');
      if (indicatorCharts[expandedIndicator]) {
        indicatorCharts[expandedIndicator].destroy();
        delete indicatorCharts[expandedIndicator];
      }
    }
    element.classList.add('expanded');
    expandedIndicator = key;
    loadAndRenderIndicatorHistory(key, type);
  }
}

async function loadAndRenderIndicatorHistory(key, type = 'indicator') {
  const indicator = type === 'valuation' ? VALUATIONS[key] : INDICATORS[key];
  if (!indicator) return;

  if (type === 'valuation' || !indicator.fromFred) {
    renderNoHistoryMessage(key, type);
    return;
  }

  showLoading(`Loading historical data for ${indicator.label}...`);

  try {
    const history = await loadHistoricalData(indicator.fredId, indicator);
    if (history && history.length > 0) {
      // default period 12M
      renderIndicatorHistory(key, type, history, '12M');
      updateHistoryStats(key, type, history);
      setupHistoryButtons(key, type, history);
    } else {
      renderNoHistoryMessage(key, type);
    }
  } catch (error) {
    console.error(`Error loading historical data for ${key}:`, error);
    renderNoHistoryMessage(key, type);
  } finally {
    hideLoading();
  }
}

function setupHistoryButtons(key, type, historyData) {
  const cardSelector = type === 'valuation'
    ? `[data-val-card="${key}"]`
    : `[data-ind-card="${key}"]`;

  const card = document.querySelector(cardSelector);
  if (!card) return;
  const buttons = card.querySelectorAll('.period-btn');
  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      const period = btn.getAttribute('data-period');
      buttons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderIndicatorHistory(key, type, historyData, period);
      updateHistoryStats(key, type, historyData);
    });
  });
}

async function loadHistoricalData(fredId, indicator) {
  if (historicalData[fredId]) {
    return historicalData[fredId];
  }

  try {
    if (!fredCache) {
      const res = await fetch('data/fred_cache.json');
      if (!res.ok) throw new Error(`HTTP error ${res.status}`);
      fredCache = await res.json();
    }
    const seriesMap = fredCache.series || {};
    const seriesData = seriesMap[fredId];
    if (!seriesData || !Array.isArray(seriesData.observations)) {
      console.warn(`No historical data for ${fredId}`);
      return [];
    }
    const processed = processFredSeries(fredId, seriesData);
    historicalData[fredId] = processed;
    return processed;
  } catch (err) {
    console.error('loadHistoricalData error:', err);
    return [];
  }
}

function renderNoHistoryMessage(key, type) {
  const selector = type === 'valuation' 
    ? `[data-val-card="${key}"] .history-chart-container`
    : `[data-ind-card="${key}"] .history-chart-container`;
  const container = document.querySelector(selector);
  if (container) {
    container.innerHTML = '<div class="no-data-message">Historical data not available</div>';
  }

  const statsSelector = type === 'valuation' 
    ? `[data-val-card="${key}"] .history-stats`
    : `[data-ind-card="${key}"] .history-stats`;
  const statsEl = document.querySelector(statsSelector);
  if (statsEl) {
    statsEl.innerHTML = '<div class="no-data-message">No historical statistics</div>';
  }
}

// Determine slice size per period/FRED id
function filterHistoryByPeriod(historyData, period, fredId) {
  if (!Array.isArray(historyData) || historyData.length === 0) return [];

  let limit;
  const isWeekly = fredId === 'ICSA';

  if (period === '5Y') {
    limit = isWeekly ? 260 : 60; // approx 5y
  } else if (period === 'MAX') {
    limit = historyData.length;
  } else {
    // 12M
    limit = isWeekly ? 52 : 12;
  }

  if (limit >= historyData.length) return historyData.slice();
  return historyData.slice(-limit);
}

// Render indicator history chart
function renderIndicatorHistory(key, type = 'indicator', historyData, period = '12M') {
  const indicator = type === 'valuation' ? VALUATIONS[key] : INDICATORS[key];
  if (!indicator) return;

  const selector = type === 'valuation'
    ? `[data-val-card="${key}"] .history-chart`
    : `[data-ind-card="${key}"] .history-chart`;

  const canvas = document.querySelector(selector);
  if (!canvas) return;
  const ctx = canvas.getContext('2d');

  const fredId = indicator.fredId || '';
  const periodData = filterHistoryByPeriod(historyData, period, fredId);
  if (!periodData.length) {
    renderNoHistoryMessage(key, type);
    return;
  }

  if (indicatorCharts[key]) {
    indicatorCharts[key].destroy();
  }

  const labels = periodData.map(item => {
    const date = new Date(item.date);
    if (isNaN(date)) return item.date;
    return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
  });
  const data = periodData.map(item => item.value);

  let minVal = Math.min(...data);
  let maxVal = Math.max(...data);

  if (!isFinite(minVal) || !isFinite(maxVal)) {
    renderNoHistoryMessage(key, type);
    return;
  }

  if (Math.abs(maxVal - minVal) < 1e-6) {
    const center = minVal;
    minVal = center - 1;
    maxVal = center + 1;
  } else {
    const span = maxVal - minVal;
    const pad = span * 0.15;
    minVal -= pad;
    maxVal += pad;
  }

  const roundTo = (value, step) => Math.round(value / step) * step;
  const step = (maxVal - minVal) > 10 ? 1 : 0.5;
  minVal = roundTo(minVal, step);
  maxVal = roundTo(maxVal, step);

  let lineColor = '#6b9eff';
  if (type === 'indicator') {
    const effValue = getScenarioValue(key, indicator.current);
    const stress = scaleIndicator(key, effValue);
    if (stress >= 66) lineColor = '#ff6070';
    else if (stress >= 33) lineColor = '#ffc247';
    else lineColor = '#1ec28b';
  } else {
    const effVal = getScenarioValue(key, indicator.current);
    const stress = valuationStress(key, effVal);
    if (stress >= 66) lineColor = '#ff6070';
    else if (stress >= 33) lineColor = '#ffc247';
    else lineColor = '#1ec28b';
  }

  indicatorCharts[key] = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: indicator.label,
        data,
        borderColor: lineColor,
        backgroundColor: lineColor + '20',
        borderWidth: 2,
        tension: 0.3,
        fill: true,
        pointRadius: 2,
        pointBackgroundColor: lineColor,
        pointBorderColor: '#12182b',
        pointBorderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(18, 24, 43, 0.9)',
          titleColor: '#e8eeff',
          bodyColor: '#e8eeff',
          borderColor: 'rgba(255,255,255,0.1)',
          borderWidth: 1,
          cornerRadius: 4,
          displayColors: false,
          callbacks: {
            label: function (context) {
              const value = context.parsed.y;
              return indicator.format ? indicator.format(value) : value;
            }
          }
        }
      },
      scales: {
        y: {
          min: minVal,
          max: maxVal,
          grid: { color: 'rgba(255,255,255,0.05)' },
          ticks: { color: '#8b96b0', font: { size: 9 } }
        },
        x: {
          grid: { color: 'rgba(255,255,255,0.03)' },
          ticks: { color: '#8b96b0', font: { size: 9 } }
        }
      }
    }
  });
}

// Update history statistics
function updateHistoryStats(key, type = 'indicator', historyData) {
  const indicator = type === 'valuation' ? VALUATIONS[key] : INDICATORS[key];
  if (!indicator || !historyData || historyData.length === 0) return;
  
  const values = historyData.map(item => item.value).filter(v => Number.isFinite(v));
  if (!values.length) return;

  const current = values[values.length - 1];
  const threeMonthsAgo = values.length >= 4 ? values[values.length - 4] : null;
  const sixMonthsAgo = values.length >= 7 ? values[values.length - 7] : null;
  const twelveMonthsAgo = values.length >= 13 ? values[values.length - 13] : null;
  
  const pct = (now, then) =>
    (then !== null && then !== 0 && now !== null)
      ? ((now - then) / Math.abs(then)) * 100
      : null;

  const threeMonthChange = pct(current, threeMonthsAgo);
  const sixMonthChange = pct(current, sixMonthsAgo);
  const twelveMonthChange = pct(current, twelveMonthsAgo);
  
  const statsContainer = type === 'valuation' 
    ? document.querySelector(`[data-val-card="${key}"] .history-stats`)
    : document.querySelector(`[data-ind-card="${key}"] .history-stats`);
  
  if (!statsContainer) return;
  
  statsContainer.innerHTML = `
    <div class="history-stat">
      <div class="history-stat-label">Current</div>
      <div class="history-stat-value">${indicator.format ? indicator.format(current) : current.toFixed(2)}</div>
    </div>
    <div class="history-stat">
      <div class="history-stat-label">3M Change</div>
      <div class="history-stat-value" style="color: ${threeMonthChange !== null && threeMonthChange >= 0 ? '#1ec28b' : '#ff6070'}">
        ${threeMonthChange !== null ? threeMonthChange.toFixed(1) + '%' : '--'}
      </div>
    </div>
    <div class="history-stat">
      <div class="history-stat-label">6M Change</div>
      <div class="history-stat-value" style="color: ${sixMonthChange !== null && sixMonthChange >= 0 ? '#1ec28b' : '#ff6070'}">
        ${sixMonthChange !== null ? sixMonthChange.toFixed(1) + '%' : '--'}
      </div>
    </div>
    <div class="history-stat">
      <div class="history-stat-label">12M Change</div>
      <div class="history-stat-value" style="color: ${twelveMonthChange !== null && twelveMonthChange >= 0 ? '#1ec28b' : '#ff6070'}">
        ${twelveMonthChange !== null ? twelveMonthChange.toFixed(1) + '%' : '--'}
      </div>
    </div>
  `;
}

// === FRED cache load (single source) ===
async function loadFromFredCache(){
  try{
    showLoading('Loading FRED data...');
    const res = await fetch('data/fred_cache.json', { cache:'no-store' });
    if(!res.ok){
      console.error('FRED cache HTTP error', res.status);
      document.getElementById('cache-badge').textContent = 'FRED cache: not found';
      hideLoading();
      return;
    }

    fredCache = await res.json();
    const series = fredCache.series || {};
    const gen = fredCache.generated_at || 'loaded';
    document.getElementById('cache-badge').textContent = 'FRED cache: ' + gen;

    // Cache age
    const genDate = new Date(gen);
    if(!isNaN(genDate)){
      const now = new Date();
      cacheAgeDays = (now - genDate) / (1000*60*60*24);
      if(cacheAgeDays < 0) cacheAgeDays = null;
    }

    // Process and assign indicator currents & data age
    Object.keys(INDICATORS).forEach(key => {
      const ind = INDICATORS[key];
      if (!ind.fromFred || !ind.fredId) return;

      const s = series[ind.fredId];
      if (!s || !Array.isArray(s.observations) || !s.observations.length) {
        console.warn(`Missing series for ${ind.fredId}`);
        ind.current = null;
        ind.lastObsDate = null;
        ind.dataAgeDays = null;
        return;
      }

      // Ensure processed series cached
      const processed = processFredSeries(ind.fredId, s);
      historicalData[ind.fredId] = processed;

      if (!processed.length) {
        ind.current = null;
        ind.lastObsDate = null;
        ind.dataAgeDays = null;
        return;
      }

      const lastPoint = processed[processed.length - 1];
      const val = Number(lastPoint.value);
      ind.current = Number.isFinite(val) ? val : null;
      ind.lastObsDate = lastPoint.date || null;

      if (ind.lastObsDate) {
        const d = new Date(ind.lastObsDate);
        if (!isNaN(d)) {
          const now = new Date();
          ind.dataAgeDays = (now - d) / (1000*60*60*24);
        } else {
          ind.dataAgeDays = null;
        }
      } else {
        ind.dataAgeDays = null;
      }
    });

    hideLoading();
  }catch(err){
    console.error('FRED cache error:', err);
    document.getElementById('cache-badge').textContent = 'FRED cache: error';
    hideLoading();
  }
}

// === Stress scaling ===
function scaleIndicator(key, value){
  const ind = INDICATORS[key];
  if(!ind || !Number.isFinite(value)) return null;

  const t = ind.threshold;
  const dir = ind.direction;
  const span = (ind.span && ind.span > 0)
    ? ind.span
    : Math.max(1, Math.abs(t) * 0.5);
  const buffer = (ind.buffer && ind.buffer > 0)
    ? ind.buffer
    : span * 0.5;

  let stress = 0;

  if(dir === 'below'){
    const safeCut = t + buffer;
    if(value >= safeCut){
      stress = 0;
    } else if(value >= t){
      const frac = (safeCut - value) / buffer;
      stress = frac * WARN_MAX;
    } else {
      const frac = Math.max(0, Math.min(1, (t - value) / span));
      stress = WARN_MAX + frac * (100 - WARN_MAX);
    }
  } else if(dir === 'above'){
    const safeCut = t - buffer;
    if(value <= safeCut){
      stress = 0;
    } else if(value <= t){
      const frac = (value - safeCut) / buffer;
      stress = frac * WARN_MAX;
    } else {
      const frac = Math.max(0, Math.min(1, (value - t) / span));
      stress = WARN_MAX + frac * (100 - WARN_MAX);
    }
  } else {
    return null;
  }

  if(key === 'YIELD_CURVE' && value <= 0){
    stress = Math.min(100, stress * 1.2);
  }
  if(key === 'SAHM_RULE' && value >= 0.5){
    stress = Math.min(100, stress * 1.3);
  }

  if(!Number.isFinite(stress)) return null;
  if(stress < 0) stress = 0;
  if(stress > 100) stress = 100;
  return stress;
}

function valuationStress(key, val){
  if(!Number.isFinite(val)) return null;
  let s = 0;

  if(key === 'BUFFETT'){
    if(val <= 120){
      s = 0;
    } else if(val <= 150){
      const frac = (val - 120) / (150 - 120);
      s = frac * 40;
    } else if(val <= 200){
      const frac = (val - 150) / (200 - 150);
      s = 40 + frac * 60;
    } else {
      s = 100;
    }
  } else if(key === 'SHILLER_PE'){
    if(val <= 22){
      s = 0;
    } else if(val <= 30){
      const frac = (val - 22) / (30 - 22);
      s = frac * 40;
    } else if(val <= 40){
      const frac = (val - 30) / (40 - 30);
      s = 40 + frac * 60;
    } else {
      s = 100;
    }
  } else {
    return null;
  }

  if(s < 0) s = 0;
  if(s > 100) s = 100;
  return s;
}

// Composite with optional scenario overrides
function computeComposite(){
  let macroStress = 0;
  let macroTotalWeight = 0;

  Object.entries(INDICATORS).forEach(([k, ind]) => {
    const effVal = getScenarioValue(k, ind.current);
    const s = scaleIndicator(k, effVal);
    if(s !== null && Number.isFinite(s) && ind.weight){
      macroStress += s * ind.weight;
      macroTotalWeight += ind.weight;
    }
  });

  let valStress = 0;
  let valTotalWeight = 0;

  Object.entries(VALUATIONS).forEach(([k, v]) => {
    const effVal = getScenarioValue(k, v.current);
    const s = valuationStress(k, effVal);
    if(s !== null && Number.isFinite(s) && v.weight){
      valStress += s * v.weight;
      valTotalWeight += v.weight;
    }
  });

  if(macroTotalWeight === 0 && valTotalWeight === 0) return null;

  const macroComponent = macroTotalWeight > 0 ? (macroStress / macroTotalWeight) : null;
  const valComponent = valTotalWeight > 0 ? (valStress / valTotalWeight) : null;

  let composite = null;
  if(macroComponent !== null && valComponent !== null){
    composite = macroComponent * MACRO_BLOCK_WEIGHT + valComponent * VALUATION_BLOCK_WEIGHT;
  } else if(macroComponent !== null){
    composite = macroComponent;
  } else {
    composite = valComponent;
  }

  if(!Number.isFinite(composite)) return null;
  if(composite < 0) composite = 0;
  if(composite > 100) composite = 100;
  return composite;
}

function derivedRecessionRisk(c){
  if(c == null) return '--';
  if(c < 20) return '<10%';
  if(c < 35) return '10â€“25%';
  if(c < 50) return '25â€“40%';
  if(c < 65) return '40â€“60%';
  if(c < 80) return '60â€“75%';
  return '75â€“90%';
}

function derivedValuationRisk(){
  let sum = 0, w = 0;
  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const effVal = getScenarioValue(k, v.current);
    const s = valuationStress(k, effVal);
    if(s != null && v.weight){
      sum += s * v.weight;
      w   += v.weight;
    }
  });
  if(!w) return '--';
  const sc = Math.round(sum / w);
  if(sc < 33) return 'Low';
  if(sc < 66) return 'Moderate';
  return 'High';
}

function derivedLaborStress(){
  const c = getScenarioValue('INITIAL_CLAIMS', INDICATORS.INITIAL_CLAIMS.current);
  const s = getScenarioValue('SAHM_RULE', INDICATORS.SAHM_RULE.current);
  if(!Number.isFinite(c) || !Number.isFinite(s)) return '--';
  const cs = Math.max(0, Math.min(100, (c - 250) * 0.5));
  const ss = Math.max(0, Math.min(100, s * 200));
  const avg = (cs + ss) / 2;
  if(avg < 30) return 'Low';
  if(avg < 60) return 'Moderate';
  return 'High';
}

// === Indicator tiles ===
function dataAgeClass(days, fredId) {
  if (days == null || !fredId) return 'data-age-old';
  const cadence = CADENCE_DAYS[fredId] || 60;
  if (days <= cadence * 1.2) return 'data-age-fresh';
  if (days <= cadence * 2.0) return 'data-age-stale';
  return 'data-age-old';
}

function dataAgeText(ind) {
  if (!ind.fromFred || !ind.lastObsDate) return 'Data age: n/a';
  const days = ind.dataAgeDays;
  if (days == null) return `Latest: ${ind.lastObsDate}`;
  const d = days.toFixed(1);
  return `Latest: ${ind.lastObsDate} (${d} days old)`;
}

function buildIndicatorElement(key, ind){
  const effVal = getScenarioValue(key, ind.current);
  const s = scaleIndicator(key, effVal);
  let cls = 'indicator';
  if(s != null){
    if(s >= 66) cls += ' danger';
    else if(s >= 33) cls += ' warning';
  }

  const hasVal = Number.isFinite(ind.current);
  const valText = hasVal ? ind.format(ind.current) : '--';

  const thrText = (ind.threshold != null && ind.format)
    ? 'Threshold pivot: ' + ind.format(ind.threshold) +
      (ind.direction === 'below' ? ' (worse below)' : ' (worse above)')
    : '';

  const stressText = (s != null)
    ? 'Stress: ' + Math.round(s) + '/100'
    : 'Stress: --';

  const src = ind.fromFred ? 'Auto from FRED' : 'Manual input';
  const srcClass = ind.fromFred ? 'data-source-auto' : 'data-source-manual';

  const ageCls = dataAgeClass(ind.dataAgeDays, ind.fredId);
  const ageText = dataAgeText(ind);

  let manual = '';
  if(!ind.fromFred && key === 'LEI'){
    manual =
      '<div class="manual-input-row">' +
        '<span>Set latest 6m %Î” for LEI:</span>' +
        '<input class="manual-input" type="number" step="0.1" ' +
        'data-ind-key="'+key+'" value="'+(hasVal ? ind.current : '')+'">' +
      '</div>';
  }

  const historySection = ind.fromFred ? `
    <div class="indicator-history" data-history-key="${key}">
      <div class="history-period-selector">
        <button class="period-btn active" data-period="12M">12M</button>
        <button class="period-btn" data-period="5Y">5Y</button>
        <button class="period-btn" data-period="MAX">MAX</button>
      </div>
      <div class="history-chart-container">
        <canvas class="history-chart"></canvas>
      </div>
      <div class="history-stats"></div>
    </div>
  ` : '';

  const div = document.createElement('div');
  div.className = cls;
  div.setAttribute('data-ind-card', key);
  div.innerHTML =
    '<div class="indicator-header">' +
      '<div class="indicator-name">'+ind.label+'</div>' +
      '<div class="indicator-value" data-ind-value="'+key+'">'+valText+'</div>' +
    '</div>' +
    '<div class="indicator-threshold">'+thrText+'</div>' +
    '<div class="indicator-threshold" data-ind-stress="'+key+'">'+stressText+'</div>' +
    '<div class="indicator-threshold">'+ind.desc+'</div>' +
    '<div class="data-source-indicator">' +
      '<span class="data-source-dot ' + srcClass + '"></span>' +
      '<span class="source-tag">'+src+'</span>' +
    '</div>' +
    '<div class="indicator-threshold data-age-label '+ageCls+'">'+ageText+'</div>' +
    manual +
    historySection;

  if (ind.fromFred) {
    div.addEventListener('click', (e) => {
      if (!e.target.classList.contains('manual-input')) {
        toggleIndicatorExpansion(key, 'indicator');
      }
    });
  }

  div.addEventListener('mouseenter', (e) => {
    if (ind.tooltip) showTooltip(ind.tooltip, e.pageX + 10, e.pageY + 10);
  });
  div.addEventListener('mousemove', (e) => {
    if (ind.tooltip) showTooltip(ind.tooltip, e.pageX + 10, e.pageY + 10);
  });
  div.addEventListener('mouseleave', () => hideTooltip());

  return div;
}

function renderIndicators(){
  const t1 = document.getElementById('tier1-indicators');
  const t2 = document.getElementById('tier2-indicators');
  if (!t1 || !t2) return;
  t1.innerHTML = '';
  t2.innerHTML = '';

  Object.entries(INDICATORS).forEach(([k,ind]) => {
    const el = buildIndicatorElement(k, ind);
    if(ind.tier === 1) t1.appendChild(el);
    else t2.appendChild(el);
  });

  document.querySelectorAll('.manual-input[data-ind-key]').forEach(inp => {
    inp.addEventListener('input', () => {
      const key = inp.getAttribute('data-ind-key');
      const v = parseFloat(inp.value);
      INDICATORS[key].current = Number.isFinite(v) ? v : null;
      const valEl = document.querySelector('[data-ind-value="'+key+'"]');
      if(valEl){
        valEl.textContent = Number.isFinite(v)
          ? INDICATORS[key].format(v)
          : '--';
      }
      saveManualInputsToStorage();
      updateDynamic();
    });
  });
}

// === Valuation tiles ===
function renderValuations(){
  const box = document.getElementById('valuation-indicators');
  if (!box) return;
  box.innerHTML = '';

  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const effVal = getScenarioValue(k, v.current);
    const s = valuationStress(k, effVal);
    let cls = 'indicator';
    if(s != null){
      if(s >= 66) cls += ' danger';
      else if(s >= 33) cls += ' warning';
    }

    const hasVal = Number.isFinite(v.current);
    const valText = hasVal ? v.format(v.current) : '--';
    const stressText = (s != null)
      ? 'Stress: ' + Math.round(s) + '/100'
      : 'Stress: --';

    let dangerLabel = '';
    if(k === 'BUFFETT'){
      dangerLabel = 'Danger band: > 200%';
    } else if(k === 'SHILLER_PE'){
      dangerLabel = 'Danger band: > 30';
    } else {
      dangerLabel = 'Danger band: ' + v.danger;
    }

    const div = document.createElement('div');
    div.className = cls;
    div.setAttribute('data-val-card', k);
    div.innerHTML =
      '<div class="indicator-header">' +
        '<div class="indicator-name">'+v.label+'</div>' +
        '<div class="indicator-value" data-val-value="'+k+'">'+valText+'</div>' +
      '</div>' +
      '<div class="indicator-threshold">'+dangerLabel+'</div>' +
      '<div class="indicator-threshold" data-val-stress="'+k+'">'+stressText+'</div>' +
      '<div class="indicator-threshold">'+v.desc+'</div>' +
      '<div class="data-source-indicator">' +
        '<span class="data-source-dot data-source-manual"></span>' +
        '<span class="source-tag">Manual input</span>' +
      '</div>' +
      '<div class="manual-input-row">' +
        '<span>Set current reading:</span>' +
        '<input class="manual-input" type="number" step="0.1" ' +
        'data-val-key="'+k+'" value="'+(hasVal ? v.current : '')+'">' +
      '</div>';

    div.addEventListener('mouseenter', (e) => {
      if (v.tooltip) showTooltip(v.tooltip, e.pageX + 10, e.pageY + 10);
    });
    div.addEventListener('mousemove', (e) => {
      if (v.tooltip) showTooltip(v.tooltip, e.pageX + 10, e.pageY + 10);
    });
    div.addEventListener('mouseleave', () => hideTooltip());

    box.appendChild(div);
  });

  document.querySelectorAll('.manual-input[data-val-key]').forEach(inp => {
    inp.addEventListener('input', () => {
      const key = inp.getAttribute('data-val-key');
      const v = parseFloat(inp.value);
      VALUATIONS[key].current = Number.isFinite(v) ? v : null;
      const valEl = document.querySelector('[data-val-value="'+key+'"]');
      if(valEl){
        valEl.textContent = Number.isFinite(v)
          ? VALUATIONS[key].format(v)
          : '--';
      }
      saveManualInputsToStorage();
      updateDynamic();
    });
  });
}

function syncValuationCurrentBox(){
  const b = VALUATIONS.BUFFETT.current;
  const c = VALUATIONS.SHILLER_PE.current;
  const bEl = document.getElementById('current-buffett-label');
  const cEl = document.getElementById('current-cape-label');

  if(bEl){
    bEl.textContent = Number.isFinite(b)
      ? ('Buffett: ' + b.toFixed(1) + '%')
      : 'Buffett: --';
  }
  if(cEl){
    cEl.textContent = Number.isFinite(c)
      ? ('CAPE: ' + c.toFixed(1))
      : 'CAPE: --';
  }
}

// === Gauge & statuses ===
function renderGaugeAndStatus(){
  compositeScore = computeComposite();

  const scoreEl = document.getElementById('composite-score');
  const needle = document.getElementById('needle');
  const fill = document.getElementById('risk-fill');
  const regimeEl = document.getElementById('regime-label');
  const alert = document.getElementById('alert-banner');

  const total = Object.keys(INDICATORS).length + Object.keys(VALUATIONS).length;
  const used =
    Object.keys(INDICATORS).filter(k => Number.isFinite(INDICATORS[k].current)).length +
    Object.keys(VALUATIONS).filter(k => Number.isFinite(VALUATIONS[k].current)).length;

  const coverage = total ? (used / total) : 0;
  const qualityEl = document.getElementById('quality-display');
  const inputsBadge = document.getElementById('inputs-badge');

  if (inputsBadge) {
    inputsBadge.textContent = 'Inputs: ' + used + '/' + total + ' populated';
  }
  if (qualityEl) {
    qualityEl.textContent = total ? Math.round(coverage * 100) + '%' : '--';
  }

  if(compositeScore == null){
    if (scoreEl) scoreEl.textContent = '--';
    if (fill) fill.style.width = '0%';
    if (needle) needle.style.transform = 'translateX(-50%) rotate(0deg)';
    if (regimeEl) regimeEl.textContent = 'COMPOSITE STRESS â€” insufficient data';
    document.getElementById('recession-risk-display').textContent = '--';
    document.getElementById('valuation-risk-display').textContent = '--';
    document.getElementById('labor-risk-display').textContent = '--';

    let msg = 'No composite yet. Check FRED cache and manual LEI / valuation inputs.';
    if(cacheAgeDays != null && cacheAgeDays > 7){
      msg = 'Data warning: FRED cache is ' + cacheAgeDays.toFixed(1) +
            ' days old. Update fred_cache.json. ' + msg;
    }
    if (alert) alert.textContent = msg;
    return;
  }

  const v = Math.round(compositeScore);
  if (scoreEl) scoreEl.textContent = v;
  if (fill) fill.style.width = v + '%';
  if (needle) {
    const angle = (v / 100) * 360;
    needle.style.transform = 'translateX(-50%) rotate(' + angle + 'deg)';
  }

  let regime;
  if(v <= 30) regime = 'Low stress regime';
  else if(v <= 50) regime = 'Elevated â€” monitor';
  else if(v <= 70) regime = 'High â€” defensive bias';
  else regime = 'Critical regime';

  if (regimeEl) regimeEl.textContent = 'COMPOSITE STRESS â€” ' + regime;
  document.getElementById('recession-risk-display').textContent = derivedRecessionRisk(v);
  document.getElementById('valuation-risk-display').textContent = derivedValuationRisk();
  document.getElementById('labor-risk-display').textContent = derivedLaborStress();

  let prefix = '';
  if(cacheAgeDays != null && cacheAgeDays > 7){
    prefix += 'Data warning: FRED cache is ' + cacheAgeDays.toFixed(1) +
              ' days old. Update fred_cache.json. ';
  }
  if(coverage < 0.8){
    prefix += 'Coverage below 80%. Treat composite as tentative. ';
  }

  if (!alert) return;

  if(v >= 70){
    alert.innerHTML = prefix + '<strong>Critical:</strong> Composite = ' + v +
      '. Macro + valuations in historical danger cluster.';
  }else if(v >= 50){
    alert.innerHTML = prefix + '<strong>Warning:</strong> Composite = ' + v +
      '. Elevated risk â€” inspect indicator tiles.';
  }else{
    alert.textContent = prefix +
      'Composite = ' + v +
      '. No classic crash cluster on this configuration; still consider exogenous shocks.';
  }
}

// === Charts ===
function renderMarketTrendChart(){
  const canvas = document.getElementById('market-trend');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if(charts.trend) charts.trend.destroy();

  const base = compositeScore != null ? compositeScore : 40;
  const labels = ['T-10','T-8','T-6','T-4','T-2','Now'];

  const compData = [0.7,0.8,0.9,0.95,0.98,1].map(f => {
    let x = base * f;
    if(x < 0) x = 0;
    if(x > 100) x = 100;
    return Math.round(x);
  });

  let vSum = 0, vW = 0;
  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const effVal = getScenarioValue(k, v.current);
    const s = valuationStress(k, effVal);
    if(s != null && v.weight){
      vSum += s * v.weight;
      vW   += v.weight;
    }
  });
  const valBase = vW ? (vSum / vW) : 30;
  const valData = [0.75,0.85,0.92,0.96,0.99,1].map(f => {
    let x = valBase * f;
    if(x < 0) x = 0;
    if(x > 100) x = 100;
    return Math.round(x);
  });

  charts.trend = new Chart(ctx, {
    type:'line',
    data:{
      labels,
      datasets:[
        {
          label:'Composite Stress',
          data:compData,
          borderColor:'#6b9eff',
          backgroundColor:'rgba(107,158,255,0.14)',
          tension:0.32,
          fill:true,
          pointRadius:2
        },
        {
          label:'Valuation Stress',
          data:valData,
          borderColor:'#ff6070',
          backgroundColor:'rgba(255,96,112,0.12)',
          tension:0.32,
          fill:true,
          pointRadius:2
        }
      ]
    },
    options:{
      responsive:true,
      plugins:{
        legend:{labels:{color:'#e8eeff',font:{size:9}}},
        title:{
          display:true,
          text:'Stress & Valuation Trajectory (illustrative)',
          color:'#e8eeff',
          font:{size:11}
        }
      },
      scales:{
        y:{
          min:0,
          max:100,
          ticks:{color:'#8b96b0',font:{size:8}},
          grid:{color:'rgba(255,255,255,0.08)'}
        },
        x:{
          ticks:{color:'#8b96b0',font:{size:8}},
          grid:{color:'rgba(255,255,255,0.06)'}
        }
      }
    }
  });
}

function renderRiskRadarChart(){
  const canvas = document.getElementById('risk-radar');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if(charts.radar) charts.radar.destroy();

  const labels = [];
  const data = [];

  Object.entries(INDICATORS).forEach(([k,ind]) => {
    const effVal = getScenarioValue(k, ind.current);
    const s = scaleIndicator(k, effVal);
    if(s != null){
      labels.push(ind.label);
      data.push(Math.round(s));
    }
  });

  let vSum = 0, vW = 0;
  Object.entries(VALUATIONS).forEach(([k,v]) => {
    const effVal = getScenarioValue(k, v.current);
    const s = valuationStress(k, effVal);
    if(s != null && v.weight){
      vSum += s * v.weight;
      vW   += v.weight;
    }
  });
  if(vW){
    labels.push('Valuations (Buffett + CAPE)');
    data.push(Math.round(vSum / vW));
  }

  if(!labels.length) return;

  charts.radar = new Chart(ctx, {
    type:'radar',
    data:{
      labels,
      datasets:[{
        label:'Normalized Stress (0â€“100)',
        data,
        borderColor:'#6b9eff',
        backgroundColor:'rgba(107,158,255,0.18)',
        pointRadius:2
      }]
    },
    options:{
      responsive:true,
      plugins:{legend:{display:false}},
      scales:{
        r:{
          angleLines:{color:'rgba(255,255,255,0.05)'},
          grid:{color:'rgba(255,255,255,0.09)'},
          suggestedMin:0,
          suggestedMax:100,
          ticks:{display:false},
          pointLabels:{color:'#8b96b0',font:{size:7}}
        }
      }
    }
  });
}

// === Insight text ===
function updateInsight(){
  const el = document.getElementById('insight-text');
  if(!el) return;
  const c = compositeScore;
  const vRisk = derivedValuationRisk();

  if(c == null){
    el.textContent = 'No composite yet. Ensure fred_cache.json is fresh and LEI / Buffett / CAPE are populated.';
  } else if(c >= 70 && vRisk === 'High'){
    el.textContent = 'Macro + valuations both extreme: configuration consistent with major drawdown regimes.';
  } else if(c >= 50 && vRisk !== 'Low'){
    el.textContent = 'Elevated macro stress with stretched valuations: risk-reward skewed left.';
  } else if(c < 40 && vRisk === 'High'){
    el.textContent = 'Macro relatively okay but valuations rich: vulnerable to shocks or policy error.';
  } else if(c < 40 && vRisk === 'Low'){
    el.textContent = 'Macro and valuations both moderate vs history: no classic crash cluster here.';
  } else {
    el.textContent = 'Mixed configuration. Use radar and tiles to see what drives the score.';
  }
}

// === Export ===
function exportToCSV() {
  let csvContent = "Indicator,Current Value,Stress Score,Threshold\n";
  
  Object.entries(INDICATORS).forEach(([key, ind]) => {
    const effVal = getScenarioValue(key, ind.current);
    const stress = scaleIndicator(key, effVal);
    const stressText = stress !== null ? stress.toFixed(1) : 'N/A';
    const valueText = ind.current !== null ? ind.current : 'N/A';
    const thresholdText = ind.threshold !== null ? ind.threshold : 'N/A';
    csvContent += `"${ind.label}","${valueText}","${stressText}","${thresholdText}"\n`;
  });
  
  Object.entries(VALUATIONS).forEach(([key, val]) => {
    const effVal = getScenarioValue(key, val.current);
    const stress = valuationStress(key, effVal);
    const stressText = stress !== null ? stress.toFixed(1) : 'N/A';
    const valueText = val.current !== null ? val.current : 'N/A';
    const thresholdText = val.danger !== null ? val.danger : 'N/A';
    csvContent += `"${val.label}","${valueText}","${stressText}","${thresholdText}"\n`;
  });
  
  csvContent += `"Composite Score","${compositeScore !== null ? compositeScore.toFixed(1) : 'N/A'}","",""\n`;
  
  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `economic_crash_radar_${new Date().toISOString().split('T')[0]}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function exportToPDF() {
  showLoading('Generating PDF report...');
  setTimeout(() => {
    alert('PDF export is not fully implemented here. Use a library such as jsPDF in production for a real PDF report.');
    hideLoading();
  }, 800);
}

// === Snapshots & share ===
function saveSnapshot() {
  const snapshot = {
    timestamp: new Date().toISOString(),
    compositeScore: compositeScore,
    indicators: {},
    valuations: {}
  };
  
  Object.entries(INDICATORS).forEach(([key, ind]) => {
    snapshot.indicators[key] = ind.current;
  });
  
  Object.entries(VALUATIONS).forEach(([key, val]) => {
    snapshot.valuations[key] = val.current;
  });
  
  const snapshots = JSON.parse(localStorage.getItem('crashRadarSnapshots') || '[]');
  snapshots.push(snapshot);
  localStorage.setItem('crashRadarSnapshots', JSON.stringify(snapshots));
  
  alert('Snapshot saved (stored in localStorage).');
}

function shareLink() {
  const params = new URLSearchParams();
  
  Object.entries(INDICATORS).forEach(([key, ind]) => {
    if (ind.current !== null) {
      params.set(`i_${key}`, ind.current.toString());
    }
  });
  
  Object.entries(VALUATIONS).forEach(([key, val]) => {
    if (val.current !== null) {
      params.set(`v_${key}`, val.current.toString());
    }
  });
  
  const shareUrl = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
  
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(shareUrl).then(() => {
      alert('Shareable link copied to clipboard!');
    }).catch(() => {
      const textArea = document.createElement('textarea');
      textArea.value = shareUrl;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      alert('Shareable link copied to clipboard!');
    });
  } else {
    const textArea = document.createElement('textarea');
    textArea.value = shareUrl;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    alert('Shareable link copied to clipboard!');
  }
}

function resetInputs() {
  if (!confirm('Reset LEI / Buffett / CAPE and clear manual entries?')) return;

  Object.entries(INDICATORS).forEach(([key, ind]) => {
    if (!ind.fromFred) ind.current = null;
  });
  Object.entries(VALUATIONS).forEach(([key, val]) => {
    val.current = null;
  });

  localStorage.removeItem(MANUAL_STORAGE_KEY);
  updateAll();
}

function showHelp() {
  const helpText =
    'Economic Crash Radar Pro v7\n\n' +
    'Macro Indicators (10):\n' +
    'Tier 1 (Leading): LEI, Yield Curve, HY Credit Spread, NFCI, UMich Sentiment, M2 Growth\n' +
    'Tier 2 (Confirming): Industrial Production, Building Permits, Initial Claims, Sahm Rule\n\n' +
    'Valuation Indicators (2):\n' +
    'Buffett Indicator, Shiller CAPE\n\n' +
    'How to use:\n' +
    '1) Ensure FRED cache is fresh (fred_cache.json).\n' +
    '2) Enter LEI 6m %Î”, Buffett %, and CAPE manually.\n' +
    '3) Use composite score, tiles, and history charts to assess stress.\n' +
    '4) Scenario overrides let you test hypothetical values without overwriting stored inputs.';
  alert(helpText);
}

// === Manual input persistence ===
function saveManualInputsToStorage() {
  const payload = {
    LEI: INDICATORS.LEI.current,
    BUFFETT: VALUATIONS.BUFFETT.current,
    SHILLER_PE: VALUATIONS.SHILLER_PE.current
  };
  localStorage.setItem(MANUAL_STORAGE_KEY, JSON.stringify(payload));
}

function loadManualInputsFromStorage() {
  try {
    const raw = localStorage.getItem(MANUAL_STORAGE_KEY);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (data && typeof data === 'object') {
      if (Number.isFinite(data.LEI)) INDICATORS.LEI.current = data.LEI;
      if (Number.isFinite(data.BUFFETT)) VALUATIONS.BUFFETT.current = data.BUFFETT;
      if (Number.isFinite(data.SHILLER_PE)) VALUATIONS.SHILLER_PE.current = data.SHILLER_PE;
    }
  } catch (e) {
    console.warn('Manual storage parse error:', e);
  }
}

// === URL param load ===
function loadFromURL() {
  const urlParams = new URLSearchParams(window.location.search);
  
  Object.entries(INDICATORS).forEach(([key, ind]) => {
    const paramValue = urlParams.get(`i_${key}`);
    if (paramValue !== null) {
      const value = parseFloat(paramValue);
      if (!isNaN(value)) {
        ind.current = value;
      }
    }
  });
  
  Object.entries(VALUATIONS).forEach(([key, val]) => {
    const paramValue = urlParams.get(`v_${key}`);
    if (paramValue !== null) {
      const value = parseFloat(paramValue);
      if (!isNaN(value)) {
        val.current = value;
      }
    }
  });
}

// === Scenario wiring ===
function wireScenarioPanel() {
  const toggle = document.getElementById('scenario-toggle');
  if (!toggle) return;

  toggle.addEventListener('change', () => {
    scenarioMode = toggle.checked;
    updateDynamic();
  });

  const bindScenario = (id, key) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', () => {
      const v = parseFloat(el.value);
      if (Number.isFinite(v)) scenarioOverrides[key] = v;
      else delete scenarioOverrides[key];
      if (scenarioMode) updateDynamic();
    });
  };

  bindScenario('scenario-LEI', 'LEI');
  bindScenario('scenario-YIELD_CURVE', 'YIELD_CURVE');
  bindScenario('scenario-CREDIT_SPREAD', 'CREDIT_SPREAD');
  bindScenario('scenario-M2_GROWTH', 'M2_GROWTH');
  bindScenario('scenario-BUFFETT', 'BUFFETT');
  bindScenario('scenario-SHILLER_PE', 'SHILLER_PE');
}

// === Orchestration ===
function updateDynamic(){
  renderGaugeAndStatus();
  renderMarketTrendChart();
  renderRiskRadarChart();
  syncValuationCurrentBox();
  updateInsight();
}

function updateAll(){
  renderIndicators();
  renderValuations();
  updateDynamic();
}

document.addEventListener('DOMContentLoaded', () => {
  // 1) URL params override
  loadFromURL();
  // 2) Local storage for manual inputs (only where URL not present)
  loadManualInputsFromStorage();

  // 3) Load FRED + render
  loadFromFredCache()
    .then(updateAll)
    .catch(err => {
      console.error('Init error:', err);
      updateAll();
    });

  const refreshBtn = document.getElementById('refresh-data');
  if (refreshBtn) {
    refreshBtn.addEventListener('click', () => {
      loadFromFredCache()
        .then(updateAll)
        .catch(err => {
          console.error('Refresh error:', err);
          updateAll();
        });
    });
  }

  const resetBtn = document.getElementById('reset-inputs');
  if (resetBtn) resetBtn.addEventListener('click', resetInputs);

  const helpBtn = document.getElementById('show-help');
  if (helpBtn) helpBtn.addEventListener('click', showHelp);

  const exportCsvBtn = document.getElementById('export-csv');
  if (exportCsvBtn) exportCsvBtn.addEventListener('click', exportToCSV);

  const exportPdfBtn = document.getElementById('export-pdf');
  if (exportPdfBtn) exportPdfBtn.addEventListener('click', exportToPDF);

  const snapshotBtn = document.getElementById('export-snapshot');
  if (snapshotBtn) snapshotBtn.addEventListener('click', saveSnapshot);

  const shareBtn = document.getElementById('share-link');
  if (shareBtn) shareBtn.addEventListener('click', shareLink);

  wireScenarioPanel();
});
</script>
</body>
</html>
