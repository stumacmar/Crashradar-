<script>
/* ========= Robust FRED cache loader (supports multiple layouts) ========= */
const FRED_CACHE_PATH = 'data/fred_cache.json';

/* Optional: set this in a small <script> above if you want live fallback
   <script>window.FRED_API_KEY = 'YOUR_FRED_KEY';</script>
*/
const FRED_API_KEY = window.FRED_API_KEY || null;

/* 1) Read the cache and normalize to a simple map: { seriesId -> {observations, fetchedAt} } */
async function loadFredCache(){
  const res = await fetch(FRED_CACHE_PATH, { cache:'no-store' });
  if(!res.ok) throw new Error(`FRED cache: HTTP ${res.status}`);
  const raw = await res.json();
  return normalizeCache(raw);
}

function normalizeCache(raw){
  // We support three shapes:
  // A) { "T10Y3M": {observations:[...]} , "UNRATE": {...}, ... }
  // B) { series: [ { id:"T10Y3M", observations:[...] }, ... ] }
  // C) [ { id:"T10Y3M", observations:[...] }, ... ]  (top-level array)
  const out = {};

  // A) direct-map detection: has some known keys with observations array
  const directLike = Object.keys(raw||{}).some(k => raw[k] && Array.isArray(raw[k].observations));
  if (directLike) {
    for (const [k,v] of Object.entries(raw)) {
      if (v && Array.isArray(v.observations)) out[k] = v;
    }
    return out;
  }

  // B) wrapped array at raw.series
  if (Array.isArray(raw?.series)) {
    for (const item of raw.series) {
      const id = item?.id || item?.series_id || item?.name;
      if (!id) continue;
      if (Array.isArray(item.observations)) out[id] = { observations: item.observations, fetchedAt: item.fetchedAt };
      // handle alt shapes where data sits under "data" etc.
      else if (Array.isArray(item.data)) out[id] = { observations: item.data, fetchedAt: item.fetchedAt };
    }
    return out;
  }

  // C) top-level array of series objects
  if (Array.isArray(raw)) {
    for (const item of raw) {
      const id = item?.id || item?.series_id || item?.name;
      if (!id) continue;
      const obs = Array.isArray(item.observations) ? item.observations
                : Array.isArray(item.data) ? item.data
                : [];
      if (obs.length) out[id] = { observations: obs, fetchedAt: item.fetchedAt };
    }
    return out;
  }

  // If we’re here, shape is unknown. Return empty map; caller will surface which keys are missing.
  return out;
}

/* 2) Small helpers reused below */
function latest(series){
  const obs = series?.observations||[];
  if(!obs.length) return null;
  const o = obs[obs.length-1];
  const v = (o.value==null || o.value==='.' || o.value==='NaN') ? null : +o.value;
  return {value:v, date:o.date};
}
function latestVal(series){ const L = latest(series); return L?.value ?? null; }
function seriesAgeDays(series, fetchedAt){
  const L = latest(series);
  if(!L) return Infinity;
  const d = new Date(L.date + 'T00:00:00Z');
  return Math.max(0, Math.round((new Date(fetchedAt || Date.now()) - d) / 86400000));
}
function freshnessPenalty(days, cadence){
  const lim = FRESH_LIMITS[cadence] || FRESH_LIMITS.daily;
  if(days<=lim.ok) return 1.00;
  if(days<=lim.warn) return 0.85;
  return 0.70;
}

/* 3) Derivations (unchanged logic) */
function deriveUnempSlope6(UNRATE){
  const L = latest(UNRATE); if(!L?.date || L.value==null) return null;
  const back = new Date(L.date + 'T00:00:00Z'); back.setMonth(back.getMonth()-6);
  const iso = back.toISOString().slice(0,10);
  const obs = UNRATE.observations||[];
  for(let i=obs.length-1;i>=0;i--){
    if(obs[i].date<=iso){
      const v = obs[i].value; if(v!=null && v!=='.' && v!=='NaN') return L.value - (+v);
      break;
    }
  }
  return null;
}
function deriveDrawdown12m(SP500){
  const L = latest(SP500); if(!L?.date || L.value==null) return null;
  const end = L.date;
  const start = new Date(end+'T00:00:00Z'); start.setFullYear(start.getFullYear()-1);
  const startIso = start.toISOString().slice(0,10);
  let maxv = -Infinity;
  for(const o of SP500.observations||[]){
    if(o.date>=startIso && o.date<=end){
      const v = (o.value==null||o.value==='.'||o.value==='NaN')?null:+o.value;
      if(v!=null) maxv = Math.max(maxv, v);
    }
  }
  if(!isFinite(maxv) || maxv<=0) return null;
  return (L.value/maxv) - 1;
}
function deriveRetailMomentum(RSAFS){
  const obs = RSAFS?.observations||[];
  if(obs.length<2) return null;
  const L = +obs[obs.length-1].value;
  let prev=null;
  for(let i=obs.length-2;i>=0;i--){
    const v = obs[i].value;
    if(v!=null && v!=='.' && v!=='NaN'){ prev = +v; break; }
  }
  if(prev==null || prev===0) return null;
  return (L/prev) - 1;
}

/* 4) Map your expected keys from whatever’s in the cache */
function mapIndicatorsFromCache(cacheMap){
  const out = {};

  // Pass-through for exact keys
  for(const k of Object.keys(INDICATORS)){
    if(cacheMap[k]) out[k] = cacheMap[k];
  }

  // Common aliasing from typical FRED ids
  if(!out.CREDIT && cacheMap.BAMLH0A0HYM2) out.CREDIT = cacheMap.BAMLH0A0HYM2;     // HY OAS
  if(!out.VIX_PROXY && cacheMap.VIXCLS)     out.VIX_PROXY = cacheMap.VIXCLS;       // VIX
  if(!out.SENTIMENT && cacheMap.UMCSENT)    out.SENTIMENT = cacheMap.UMCSENT;      // Michigan Sentiment

  if(!out.RETAIL_MOMENTUM && cacheMap.RSAFS){
    const val = deriveRetailMomentum(cacheMap.RSAFS);
    if(val!=null){
      out.RETAIL_MOMENTUM = {
        observations:[{date: latest(cacheMap.RSAFS).date, value: String(val)}],
        fetchedAt: cacheMap.RSAFS.fetchedAt || new Date().toISOString()
      };
    }
  }
  if(!out.UN_SLOPE6 && cacheMap.UNRATE){
    const val = deriveUnempSlope6(cacheMap.UNRATE);
    if(val!=null){
      out.UN_SLOPE6 = {
        observations:[{date: latest(cacheMap.UNRATE).date, value: String(val)}],
        fetchedAt: cacheMap.UNRATE.fetchedAt || new Date().toISOString()
      };
    }
  }
  if(!out.DD_12M && cacheMap.SP500){
    const val = deriveDrawdown12m(cacheMap.SP500);
    if(val!=null){
      out.DD_12M = {
        observations:[{date: latest(cacheMap.SP500).date, value: String(val)}],
        fetchedAt: cacheMap.SP500.fetchedAt || new Date().toISOString()
      };
    }
  }

  return out;
}

/* 5) Optional: live FRED fallback for any missing key (only if API key provided) */
async function fetchFromFred(seriesId){
  if(!FRED_API_KEY) return null;
  const url = `https://api.stlouisfed.org/fred/series/observations?series_id=${encodeURIComponent(seriesId)}&api_key=${encodeURIComponent(FRED_API_KEY)}&file_type=json`;
  try{
    const r = await fetch(url);
    if(!r.ok) return null;
    const j = await r.json();
    const obs = Array.isArray(j?.observations) ? j.observations.map(o=>({date:o.date, value:o.value})) : [];
    if(!obs.length) return null;
    return { observations: obs, fetchedAt: new Date().toISOString() };
  }catch{ return null; }
}

/* 6) Main loader used by the app */
async function loadAllIndicators(){
  const cacheMap = await loadFredCache();
  let mapped = mapIndicatorsFromCache(cacheMap);

  // Try FRED fallback for anything still missing
  const need = Object.keys(INDICATORS).filter(k => !mapped[k]);
  for(const k of need){
    const fredId =
      k === 'T10Y3M'          ? 'T10Y3M'        :
      k === 'CREDIT'          ? 'BAMLH0A0HYM2'  :
      k === 'NFCI'            ? 'NFCI'          :
      k === 'VIX_PROXY'       ? 'VIXCLS'        :
      k === 'SENTIMENT'       ? 'UMCSENT'       :
      k === 'RETAIL_MOMENTUM' ? 'RSAFS'         :
      k; // fallback assume same id

    const data = await fetchFromFred(fredId);
    if(data) mapped[k] = data;
  }

  // Validate: surface exactly what’s still missing
  const missing = Object.keys(INDICATORS).filter(k => !mapped[k]);
  if(missing.length){
    // show which IDs we DID find, to debug quickly
    console.log('fred_cache.json keys available:', Object.keys(cacheMap).slice(0,50));
    throw new Error(`${missing.join(', ')} missing in fred_cache.json`);
  }

  return mapped;
}
</script>
